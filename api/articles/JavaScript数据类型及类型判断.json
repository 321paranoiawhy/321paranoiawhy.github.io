{"title":"JavaScript数据类型及类型判断","uid":"7db2446ec2832237dd5967bf88c6a08e","slug":"JavaScript数据类型及类型判断","date":"2022-03-25T14:04:13.000Z","updated":"2022-04-07T14:51:02.620Z","comments":true,"path":"api/articles/JavaScript数据类型及类型判断.json","keywords":null,"cover":null,"content":"<h1 id=\"JavaScript类型\"><a href=\"#JavaScript类型\" class=\"headerlink\" title=\"JavaScript类型\"></a>JavaScript类型</h1><h2 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h2><p>JavaScript基本类型有 <strong>7</strong> 种: <code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code> 和 <code>BigInt</code>, 其中<code>Symbol</code>为 <code>ECMAScript 6</code> 新增类型。</p>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>JavaScript引用类型仅 <code>Object</code> 一种。 对象指内存中可以被标识符引用的一块区域, 在 JavaScript 中, 对象还可被视为一个<strong>无序键值对</strong>的集合 (散列表), 是某个特定引用类型的实例, 通常可使用 <code>new</code> 关键字后接构造函数 (constructor)创建:</p>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">let dateObject &#x3D; new Date(); &#x2F;&#x2F; 日期对象\nlet regExpObject &#x3D; new RegExp([0-9]); &#x2F;&#x2F; 正则表达式对象\nlet object &#x3D; new Object(); &#x2F;&#x2F; 自定义对象\nlet functionObject &#x3D; new Function(); &#x2F;&#x2F; 函数对象\nlet symbolObject &#x3D; new Symbol(); &#x2F;&#x2F; 符号对象\nlet booleanObject &#x3D; new Boolean(); &#x2F;&#x2F; Boolean 对象\nlet numberObject &#x3D; new Number(); &#x2F;&#x2F; Number 对象\nlet stringObject &#x3D; new String(); &#x2F;&#x2F; String 对象\nlet arrayObject &#x3D; new Array(); &#x2F;&#x2F; Array 对象\nlet mapObject &#x3D; new Map(); &#x2F;&#x2F; Map 对象\nlet weakMapObject &#x3D; new WeakMap(); &#x2F;&#x2F; WeakMap 对象\nlet setObject &#x3D; new Set(); &#x2F;&#x2F; Set 对象\nlet weakSetObject &#x3D; new WeakSet(); &#x2F;&#x2F; WeakSet 对象\nlet errorObject &#x3D; new Error(); &#x2F;&#x2F; Error 对象\nlet typedArrayObject &#x3D; new Int8Array(2); &#x2F;&#x2F; 长度为 2 的 Int8Array 定型数组对象</code></pre>\n\n<p>其中:</p>\n<ol>\n<li><code>Boolean</code>、<code>Number</code> 和 <code>String</code> 对象为 <code>JavaScript</code> 的<strong>三大原始值包装类型</strong>, 每个原始值包装类型均映射到对应的同名原始类型, 如 <code>Boolean</code> 是对应<strong>数值</strong>的引用类型。</li>\n<li><code>Map</code>、<code>WeakMap</code>、<code>Set</code> 和 <code>WeakSet</code> 对象为 <code>JavaScript</code> 键控集 (keyed collections), 这些数据结构把对象的引用作为键。</li>\n</ol>\n<h3 id=\"BigInt-对象\"><a href=\"#BigInt-对象\" class=\"headerlink\" title=\"BigInt 对象\"></a><code>BigInt</code> 对象</h3><p><code>BigInt</code> 对象可通过 <code>BigInt</code> 函数生成 <code>BigInt</code> 类型的整数, 用以精确表示任意位数的整数。</p>\n<ol>\n<li><code>BigInt</code> 函数不能连同 <code>new</code> 关键字使用:<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">let bigIntObject &#x3D; new BigInt(1); &#x2F;&#x2F; TypeError: BigInt is not a constructor</code></pre></li>\n<li><code>BigInt</code> 函数必须有参数, 且若参数不是 <code>Number</code> 类型, 将会自动调用 <code>Number()</code> 转换规则将其转换为 <code>BigInt</code>。无法解析成 <code>Number</code> 类型的参数 (如字符串) 或参数为小数, 均会报错。</li>\n</ol>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">BigInt(); &#x2F;&#x2F; TypeError: Cannot convert undefined to a BigInt\nBigInt(undefined); &#x2F;&#x2F; TypeError: Cannot convert undefined to a BigInt\nBigInt(null); &#x2F;&#x2F; TypeError: Cannot convert null to a BigInt\nBigInt(&quot;1a&quot;); &#x2F;&#x2F; SyntaxError: Cannot convert 1a to a BigInt\nBigInt(1.5); &#x2F;&#x2F; RangeError: The number 1.5 cannot be converted to a BigInt because it is not an integer\nBigInt(1); &#x2F;&#x2F; 1n\nBigInt(true); &#x2F;&#x2F; 1n\nBigInt(false); &#x2F;&#x2F; 0n</code></pre>\n<ol start=\"3\">\n<li><code>BigInt</code> 不可与 <code>Number</code> 混合操作, 若需要，则需使用 BigInt() 或 Number() 显示转换为同一类型后再执行相应操作。<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">1n + 1; &#x2F;&#x2F; TypeError: Cannot mix BigInt and other types, use explicit conversions\n1n + BigInt(1); &#x2F;&#x2F; 2n\nNumber(1n) + 1; &#x2F;&#x2F; 2\nMath.sqrt(4n); &#x2F;&#x2F; TypeError: Cannot convert a BigInt to a number</code></pre></li>\n<li><code>BigInt</code> 类型判断。<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">Object.prototype.toString.call(BigInt(1)); &#x2F;&#x2F; &quot;[object BigInt]&quot;\nObject.prototype.toString.call(1n); &#x2F;&#x2F; &quot;[object BigInt]&quot;\nObject.prototype.toString.call(BigInt); &#x2F;&#x2F; &quot;[object Function]&quot;\ntypeof 1n; &#x2F;&#x2F; &quot;bigint&quot;\ntypeof BigInt(1); &#x2F;&#x2F; &quot;bigint&quot;\ntypeof Object(1n); &#x2F;&#x2F; &quot;object&quot;\ntypeof 1n &#x3D;&#x3D;&#x3D; typeof BigInt(1); &#x2F;&#x2F; true\ntypeof 1n &#x3D;&#x3D;&#x3D; typeof Object(1n); &#x2F;&#x2F; false</code></pre></li>\n</ol>\n<h3 id=\"Global-对象和-Math-对象\"><a href=\"#Global-对象和-Math-对象\" class=\"headerlink\" title=\"Global 对象和 Math 对象\"></a><code>Global</code> 对象和 <code>Math</code> 对象</h3><p><code>JavaScript</code> 内置对象指任何由 <code>ECMAScript 6</code> 实现提供且与宿主环境无关, 在 <code>ECMAScript</code> 程序开始执行时便已存在的对象, 有 <code>Global</code> 和 <code>Math</code> 两个内置对象。</p>\n<p><code>Global</code> 对象是 <code>JavaScript</code> 中最为特别的对象: 在大多数 <code>ECMAScript</code> 实现中无法直接访问, 为兜底对象, 浏览器将 <code>Global</code> 对象实现为 <code>window</code> 对象。在全局作用域中定义的变量和函数都会变成 <code>Global</code> 对象的属性。</p>\n<p><code>Math</code> 对象为数学常数和函数提供了静态属性和静态方法, 它没有其他 <code>JavaScript</code> 对象类似的构造函数 <code>Math()</code>, 无须实例化, 所有属性和方法可直接在 <code>Math</code> 对象上调用。<code>Math</code> 对象不是函数对象:</p>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">Object.prototype.toString.call(Math); &#x2F;&#x2F; &quot;[object Math]&quot;\nObject.prototype.toString.call(Math.sin); &#x2F;&#x2F; &quot;[object Function]&quot;\nObject.prototype.toString.call(Math.sin()); &#x2F;&#x2F; &quot;[object Number]&quot;</code></pre>\n\n<h2 id=\"基本类型与引用类型的异同\"><a href=\"#基本类型与引用类型的异同\" class=\"headerlink\" title=\"基本类型与引用类型的异同\"></a>基本类型与引用类型的异同</h2><p>基本类型也称原始类型、简单数据类型。为提升变量查询速度, 基本类型存储于<strong>栈 (stack)<strong>中, 按</strong>值</strong> (by value) 访问。</p>\n<p>引用类型也称复杂数据类型, 是保存在内存中的对象。由于 <code>JavaScript</code> 不允许直接访问内存位置, 因而也不能直接操作对象所在的内存空间, 实际操作对象的是该对象的引用而非对象本身, 也即按<strong>引用</strong> (by reference) 访问。引用类型可理解为一个指向存储对象的内存处的指针。</p>\n<h2 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h2><p>由于 <code>ECMAScript</code> 类型系统是松散的, 因此需要一些手段检测任意给定变量的数据类型。</p>\n<h3 id=\"typeof-操作符\"><a href=\"#typeof-操作符\" class=\"headerlink\" title=\"typeof 操作符\"></a>typeof 操作符</h3><p><code>typeof</code> 操作符最适合用于判断一个变量是否为原始类型, 语法为:</p>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">typeof operand\ntypeof(operand)</code></pre>\n\n<p>其中, <code>operand</code> 表示一个表示原始值或对象的一元表达式, <code>typeof</code> 操作符将返回相应的类型:</p>\n<ol>\n<li>对于除 <code>null</code> 外的基本类型, 均返回正确的结果;</li>\n<li>对于除 <code>Function</code> 外的引用类型, 均返回 <code>&quot;object&quot;</code>;</li>\n<li>对于 <code>null</code> 返回 <code>&quot;object&quot;</code>;</li>\n<li>对于 <code>Function</code>, 返回 <code>&quot;function&quot;</code></li>\n</ol>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">&#x2F;&#x2F; 原始值\ntypeof undefined; &#x2F;&#x2F; &quot;undefined&quot;\ntypeof null; &#x2F;&#x2F; &quot;object&quot;\ntypeof true; &#x2F;&#x2F; &quot;boolean&quot;\ntypeof false; &#x2F;&#x2F; &quot;boolean&quot;\ntypeof Boolean(1); &#x2F;&#x2F; &quot;boolean&quot;\ntypeof 1; &#x2F;&#x2F; &quot;number&quot;\ntypeof &quot;a&quot;; &#x2F;&#x2F; &quot;string&quot;\ntypeof Symbol(); &#x2F;&#x2F; &quot;symbol&quot;\ntypeof 1n; &#x2F;&#x2F; &quot;bigint&quot;</code></pre>\n\n<p><code>typeof</code> 操作符对 <code>null</code> 特殊值返回了 <code>&quot;object&quot;</code>, 这是因为从逻辑上讲, <code>null</code> 特殊值表示一个空对象指针 (大多数平台下其值为 <code>0x00</code>), 更多详情请查阅: <a href=\"https://2ality.com/2013/10/typeof-null.html\">The history of “typeof null”</a></p>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">&#x2F;&#x2F; 对象\ntypeof &#123;&#125;; &#x2F;&#x2F; &quot;object&quot;\ntypeof &#123;a: 1&#125;; &#x2F;&#x2F; &quot;object&quot;\ntypeof []; &#x2F;&#x2F; &quot;object&quot;\ntypeof [1, 2, 3]; &#x2F;&#x2F; &quot;object&quot;\ntypeof new Date(); &#x2F;&#x2F; &quot;object&quot;\ntypeof new RegExp([0-9]); &#x2F;&#x2F; &quot;object&quot;\ntypeof new Function(); &#x2F;&#x2F; &quot;function&quot;\ntypeof Math.sin; &#x2F;&#x2F; &quot;function&quot;\ntypeof document.all; &#x2F;&#x2F; &quot;undefined&quot;</code></pre>\n<p>对于一般对象而言, <code>typeof</code> 操作符均返回 <code>&quot;object&quot;</code>。除 <code>Function</code> 构造函数的类型为 <code>&quot;function&quot;</code>外, 其余所有构造函数的类型均为 <code>&quot;object&quot;</code>。当前所有浏览器都暴露了一个非标准宿主对象 <code>document.all</code>, <code>typeof</code> 操作符对其返回 <code>&quot;undefined&quot;</code>。</p>\n<p><code>typeof</code> 操作符对原始类型很有作用, 但对引用类型却束手无策: 它无法确定对象的确切类型 (对大多数对象均返回 <code>&quot;object&quot;</code> 同一结果)。为解决上述问题, <code>ECMAScript</code> 提供了 <code>instanceof</code> 操作符, 用以检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>\n<h3 id=\"instanceof-操作符\"><a href=\"#instanceof-操作符\" class=\"headerlink\" title=\"instanceof 操作符\"></a><code>instanceof</code> 操作符</h3><p><code>instanceof</code> 操作符语法为:</p>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">object instanceof constructor</code></pre>\n\n<p><code>instanceof</code> 操作符用于判断 <code>object</code> 是否为 <code>constructor</code> 的实例。根据定义, 所有引用类型都是 <code>Object</code> (均由 <code>Object</code> 类派生而来) 的实例, <code>instanceof</code> 操作符均返回 <code>true</code>。若用 <code>instanceof</code> 操作符检测原始值, 则始终返回 <code>false</code>。</p>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">let simpleString &#x3D; &quot;This is a simple string&quot;; &#x2F;&#x2F; 字符串\nlet stringLiteral &#x3D; &#96;This is a string literal&#96;; &#x2F;&#x2F; 模板字面量定义字符串\nlet newString &#x3D; new String(&quot;This is a new string&quot;); &#x2F;&#x2F; new + constructor\nlet newDate &#x3D; new Date(); &#x2F;&#x2F; new + constructor\nlet objectLiteral &#x3D; &#123;&#125;; &#x2F;&#x2F; 对象字面量\nlet newObject &#x3D; new Object(); &#x2F;&#x2F; new + constructor\nlet arrayLiteral &#x3D; []; &#x2F;&#x2F; 数组字面量\nlet newArray &#x3D; new Array(); &#x2F;&#x2F; new + constructor\n\nsimpleString instanceof Object; &#x2F;&#x2F; false\nstringLiteral instanceof Object; &#x2F;&#x2F; false\nnewString instanceof Object; &#x2F;&#x2F; true\nnewDate instanceof Object; &#x2F;&#x2F; true\nobjectLiteral instanceof Object; &#x2F;&#x2F; true\nnewObject instanceof Object; &#x2F;&#x2F; true\narrayLiteral instanceof Object; &#x2F;&#x2F; true\nnewArray instanceof Object; &#x2F;&#x2F; true\n\nsimpleString instanceof String; &#x2F;&#x2F; false\nstringLiteral instanceof String; &#x2F;&#x2F; false\nnewString instanceof String; &#x2F;&#x2F; true\nnewDate instanceof Date; &#x2F;&#x2F; true\nobjectLiteral instanceof Object; &#x2F;&#x2F; true\nnewObject instanceof Object; &#x2F;&#x2F; true\narrayLiteral instanceof Array; &#x2F;&#x2F; true\nnewArray instanceof Array; &#x2F;&#x2F; true\n\n1 instanceof Object; &#x2F;&#x2F; false</code></pre>\n\n<p>使用单引号 (‘’) 、双引号 (“”) 和模板字面量(&#96;&#96;) 定义的字符串非对象实例,因而 <code>instanceof</code> 操作符对其均返回 <code>false</code>。使用对象字面量 ({}) 定义的对象, 尽管原型无定义, 但 <code>instanceof</code> 操作符 对其返回 <code>true</code>。</p>\n<p>要检测对象不是某个构造函数的实例时, 可以这样操作:</p>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">&#x2F;&#x2F; 逻辑非 ! 其后的表达式须用 () 包裹, 否则 JavaScript 先执行 !obj, if 的条件表达式求职结果将始终为 false\nif (!(obj instanceof constructor)) &#123;\n    &#x2F;&#x2F; Do something like obj &#x3D; new constructor()\n&#125;</code></pre>\n\n<h3 id=\"Object-prototype-toString-call\"><a href=\"#Object-prototype-toString-call\" class=\"headerlink\" title=\"Object.prototype.toString.call()\"></a><code>Object.prototype.toString.call()</code></h3><p>toString()是 <code>Object</code> 原型对象上的一个方法, 默认返回其调用者的具体类型—— <code>toString</code> 运行时 <code>this</code> 指向的对象类型, 返回 <code>&quot;[object xxx]&quot;</code>, 其中 <code>xxx</code> 表示具体的数据类型, 如 <code>Sting</code>、<code>Number</code>、<code>Boolean</code>、<code>Undefined</code>、<code>Null</code>、<code>Date</code>、<code>RegExp</code>、<code>Function</code>、<code>Error</code>、<code>Array</code>、<code>Object</code>、<code>HTMLDocument</code> 和 <code>Window</code> 等。</p>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">Object.prototype.toString.call(&quot;&quot;); &#x2F;&#x2F; &quot;[object String]&quot;\nObject.prototype.toString.call(1); &#x2F;&#x2F; &quot;[object Number]&quot;\nObject.prototype.toString.call(true); &#x2F;&#x2F; &quot;[object Boolean]&quot;\nObject.prototype.toString.call(undefined); &#x2F;&#x2F; &quot;[object undefined]&quot;\nObject.prototype.toString.call(null); &#x2F;&#x2F; &quot;[object Null]&quot;\nObject.prototype.toString.call(new Date()); &#x2F;&#x2F; &quot;[object Date]&quot;\nObject.prototype.toString.call(new RegExp()); &#x2F;&#x2F; &quot;[object RegExp]&quot;\nObject.prototype.toString.call(new Function()); &#x2F;&#x2F; &quot;[object Function]&quot;\nObject.prototype.toString.call(new Error()); &#x2F;&#x2F; &quot;[object Error]&quot;\nObject.prototype.toString.call([]); &#x2F;&#x2F; &quot;[object Array]&quot;\nObject.prototype.toString.call(&#123;&#125;); &#x2F;&#x2F; &quot;[object Object]&quot;\nObject.prototype.toString.call(document); &#x2F;&#x2F;  &quot;[object HTMLDocument]&quot;\nObject.prototype.toString.call(window); &#x2F;&#x2F; &quot;[object Window]&quot;</code></pre>\n\n<p><code>Object.prototype.toString.call()</code> 方法对 <code>null</code> 和 <code>undefined</code> 直接返回对应的 <code>&quot;[object Null]&quot;</code> 和 <code>&quot;[object Undefined]&quot;</code> 。<br>因为大部分内置对象都会重写 <code>toString</code> 方法, 所以须使用 <code>call</code> 方法强制执行 <code>Object</code> 默认的 <code>toString</code> 方法。</p>\n<p>Warning: <code>Object.prototype.toString.call()</code> 方法 本身是允许被修改的, 因而上述代码中均基于 <code>Object.prototype.toString.call()</code> 方法未被修改的前提。</p>\n<h3 id=\"constructor-属性\"><a href=\"#constructor-属性\" class=\"headerlink\" title=\"constructor 属性\"></a><code>constructor</code> 属性</h3><p><code>constructor</code> 属性可检测某个实例对象是由哪个构造函数产生的:</p>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">let a &#x3D; 1;\na.constructor; &#x2F;&#x2F; [Function: Number]\n[].constructor; &#x2F;&#x2F; [Function: Array]\n&#123;&#125;.constructor; &#x2F;&#x2F; [Function: Object]\nnew Date().constructor; &#x2F;&#x2F; [Function: Date]\nnew RegExp().constructor; &#x2F;&#x2F; [Function: RegExp]\nnew Function().constructor; &#x2F;&#x2F; [Function: Function]\nnew Error().constructor; &#x2F;&#x2F; [Function: Error]\ntrue.constructor; &#x2F;&#x2F; [Function: Boolean]\ndocument.constructor; &#x2F;&#x2F; [Function: HTMLDocument]\nwindow.constructor; &#x2F;&#x2F; [Function: Window]\n\n</code></pre>\n<ol>\n<li><code>undefined</code> 和 <code>null</code> 无 <code>constructor</code> 属性。</li>\n<li><code>constructor</code> 属性的不稳定性: 在自定义对象时,容易重写 <code>prototype</code>, 原有的 <code>constructor</code> 引用会丢失, 变为 <code>Object</code>。<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">function F() &#123;&#125;\nF.prototype &#x3D; &#123;&#125;\nlet f &#x3D; new F();\nf.constructor &#x3D;&#x3D;&#x3D; F; &#x2F;&#x2F; false\nf.constructor; &#x2F;&#x2F; [Function: Object]</code></pre></li>\n</ol>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">function F() &#123;&#125;\nlet f &#x3D; new F();\nf.constructor &#x3D;&#x3D;&#x3D; F; &#x2F;&#x2F; true\nf.constructor; &#x2F;&#x2F; [Function: F]</code></pre>\n<h3 id=\"JavaScript-第三方库\"><a href=\"#JavaScript-第三方库\" class=\"headerlink\" title=\"JavaScript 第三方库\"></a><code>JavaScript</code> 第三方库</h3><h4 id=\"lodash-js\"><a href=\"#lodash-js\" class=\"headerlink\" title=\"lodash.js\"></a><code>lodash.js</code></h4><h4 id=\"underscore-js\"><a href=\"#underscore-js\" class=\"headerlink\" title=\"underscore.js\"></a><code>underscore.js</code></h4><h4 id=\"Node-js-的-util-模块\"><a href=\"#Node-js-的-util-模块\" class=\"headerlink\" title=\"Node.js 的 util 模块\"></a><code>Node.js</code> 的 <code>util</code> 模块</h4><p><a href=\"https://nodejs.org/api/util.html\"><code>Node.js</code> 官网: <code>util</code> 模块</a></p>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">let util &#x3D; require(&quot;util&quot;);\nlet a &#x3D; [];\nconsole.log(util.isArray(a)); &#x2F;&#x2F; true</code></pre>\n<h3 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a><code>jQuery</code></h3><p>使用 <code>jQuery</code> 提供的 <code>type()</code> 方法:</p>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">const &#123; JSDOM &#125; &#x3D; require( &quot;jsdom&quot; );\nconst &#123; window &#125; &#x3D; new JSDOM( &quot;&quot; );\nconst $ &#x3D; require( &quot;jquery&quot; )( window );\n\nconsole.log($.type([])); &#x2F;&#x2F; array\nconsole.log($.type([]) &#x3D;&#x3D;&#x3D; &quot;array&quot;); &#x2F;&#x2F; true</code></pre>\n\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">&#x2F;&#x2F; or like this\nconst &#123; JSDOM &#125; &#x3D; require( &quot;jsdom&quot; );\nconst &#123; window &#125; &#x3D; new JSDOM( &quot;&quot; );\nconst $ &#x3D; require( &quot;jquery&quot; )( window );\n\nconsole.log($.type([])); &#x2F;&#x2F; array\nconsole.log($.type([]) &#x3D;&#x3D;&#x3D; &quot;array&quot;); &#x2F;&#x2F; true</code></pre>\n\n<p>Read also:</p>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/jquery-type-method/\">JQuery | type() method</a></li>\n<li><a href=\"https://code.jquery.com/jquery-3.6.0.js\">jQuery source code</a></li>\n<li><a href=\"https://youmightnotneedjquery.com/\">You might not need jQuery</a></li>\n<li><a href=\"http://jqfundamentals.com/\">《 jQuery Fundamentals 》 by Rebecca Murphey</a></li>\n</ul>\n","text":"JavaScript类型基本类型JavaScript基本类型有 7 种: Undefined、Null、Boolean、Number、String、Symbol 和 BigInt, 其中Symbol为 ECMAScript 6 新增类型。 引用类型JavaScript引用类型仅 ...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","count":9,"path":"api/tags/JavaScript.json"},{"name":"基本类型","slug":"基本类型","count":1,"path":"api/tags/基本类型.json"},{"name":"引用类型","slug":"引用类型","count":1,"path":"api/tags/引用类型.json"},{"name":"类型判断","slug":"类型判断","count":1,"path":"api/tags/类型判断.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JavaScript%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">JavaScript类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">基本类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">引用类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BigInt-%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">BigInt 对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Global-%E5%AF%B9%E8%B1%A1%E5%92%8C-Math-%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">Global 对象和 Math 对象</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BC%82%E5%90%8C\"><span class=\"toc-text\">基本类型与引用类型的异同</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">类型判断</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#typeof-%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">typeof 操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#instanceof-%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">instanceof 操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-prototype-toString-call\"><span class=\"toc-text\">Object.prototype.toString.call()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#constructor-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">constructor 属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JavaScript-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93\"><span class=\"toc-text\">JavaScript 第三方库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#lodash-js\"><span class=\"toc-text\">lodash.js</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#underscore-js\"><span class=\"toc-text\">underscore.js</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Node-js-%E7%9A%84-util-%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">Node.js 的 util 模块</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jQuery\"><span class=\"toc-text\">jQuery</span></a></li></ol></li></ol></li></ol>","author":{"name":"paranoia","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"https://321paranoiawhy.github.io","description":"生命不息, 笔耕不辍","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"树","uid":"01cf899dac80c5a14d5d881768abc55f","slug":"树","date":"2022-03-28T16:54:52.000Z","updated":"2022-03-28T16:54:52.113Z","comments":true,"path":"api/articles/树.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"paranoia","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"https://321paranoiawhy.github.io","description":"生命不息, 笔耕不辍","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"JavaScript隐式类型转换","uid":"654476d034e547d801722bf0f52fe54c","slug":"JavaScript隐式类型转换","date":"2022-03-25T14:02:59.000Z","updated":"2022-04-07T14:38:33.060Z","comments":true,"path":"api/articles/JavaScript隐式类型转换.json","keywords":null,"cover":[],"text":"JavaScript 何时会发生隐式类型转换JavaScript 是弱类型语言, 当其期望得到某种数据类型而不得时, 会强制发生隐式类型转换。 自加操作符 (++) 和自减操作符 (--)自加操作符和自减操作符均有前缀 (prefix) 和后缀 (postfix) 之分: ++i...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","count":9,"path":"api/tags/JavaScript.json"},{"name":"隐式类型转换","slug":"隐式类型转换","count":1,"path":"api/tags/隐式类型转换.json"}],"author":{"name":"paranoia","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"https://321paranoiawhy.github.io","description":"生命不息, 笔耕不辍","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}