{"title":"JavaScript类型校验函数封装","uid":"327a088abef05846131669526f1edcfc","slug":"JavaScript类型校验函数封装","date":"2022-04-06T18:09:03.000Z","updated":"2022-04-07T10:53:34.953Z","comments":true,"path":"api/articles/JavaScript类型校验函数封装.json","keywords":null,"cover":null,"content":"<h1 id=\"类型校验函数的封装\"><a href=\"#类型校验函数的封装\" class=\"headerlink\" title=\"类型校验函数的封装\"></a>类型校验函数的封装</h1><pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">&#x2F;&#x2F; JavaScript 类型校验 checkType 函数, 返回值为字符串类型\nfunction typeCheck(value) &#123;\n    &#x2F;&#x2F; 1. null\n    &#x2F;&#x2F; typeof() 方法对 null (空对象指针) 会返回字符串 &quot;object&quot;, 因此需对 null 特殊处理\n    if (value &#x3D;&#x3D;&#x3D; null) return &quot;null&quot;;\n\n    &#x2F;&#x2F; 2. NaN\n    &#x2F;&#x2F; 对值为 NaN 的数字, 返回 &quot;number NaN&quot;\n    &#x2F;&#x2F; 利用 Number.isNaN() 方法判断 NaN, 或者利用 NaN 永不等于自身这一特性判断 NaN\n    if (Number.isNaN(value)) return &quot;number NaN&quot;;\n    &#x2F;&#x2F; if (value !&#x3D;&#x3D; value) return &quot;number NaN&quot;;\n\n    &#x2F;&#x2F; 3. +Infinity 与 -Infinity\n    &#x2F;&#x2F; 对值为 Infinity 的数字, 返回 &quot;number Infinity&quot;\n    &#x2F;&#x2F; (value &#x3D;&#x3D;&#x3D; Infinity) ? (&quot;number +Infinity&quot;) : (value &#x3D;&#x3D;&#x3D; -Infinity) ? &quot;number -Infinity&quot; : &quot;&quot;;\n    if (value &#x3D;&#x3D;&#x3D; Infinity) return &quot;number +Infinity&quot;;\n    if (value &#x3D;&#x3D;&#x3D; -Infinity) return &quot;number -Infinity&quot;;\n\n    &#x2F;&#x2F; 4. 除掉上述特殊类型 (null, NaN, +Infinity, -Infinity, BigInt) 的原始类型\n    &#x2F;&#x2F; 利用 typeof() 方法对原始类型进行类型校验\n    if (typeof (value) !&#x3D;&#x3D; &quot;object&quot;) &#123;\n        return typeof (value);\n    &#125;\n\n    &#x2F;&#x2F; 5. 对于对象, Object.prototype.toString.call() 方法返回一字符串\n    &#x2F;&#x2F; 该字符串的前七个字符为固定的 &quot;object &quot;(注意最后一个空格分隔符)\n    &#x2F;&#x2F; 第八个字符为大写, 须转换为小写, 从而对于对象返回其类型 (全小写的字符串)\n    else return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();\n&#125;\n&#x2F;&#x2F; typeCheck 函数返回值为字符串\nconsole.log(typeCheck(1) &#x3D;&#x3D;&#x3D; &quot;number&quot;); &#x2F;&#x2F; true\nconsole.log(typeCheck(1)); &#x2F;&#x2F; number\nconsole.log(typeCheck(&quot;1&quot;)); &#x2F;&#x2F; string\nconsole.log(typeCheck(&quot;&quot;)); &#x2F;&#x2F; string\nconsole.log(typeCheck(true)); &#x2F;&#x2F; boolean\nconsole.log(typeCheck(null));&#x2F;&#x2F; null\nconsole.log(typeCheck(undefined)); &#x2F;&#x2F; undefined\nconsole.log(typeCheck(NaN)); &#x2F;&#x2F; number NaN\nconsole.log(typeCheck(Infinity)); &#x2F;&#x2F; number +Infinity\nconsole.log(typeCheck(-Infinity)); &#x2F;&#x2F; number -Infinity\n&#x2F;&#x2F; 整数字面量 + n 或调用函数 BigInt() 创建大整数 BigInt\nconsole.log(typeCheck(1n)); &#x2F;&#x2F; bigint\nconsole.log(typeCheck(BigInt(1))); &#x2F;&#x2F; bigint\n&#x2F;&#x2F; 对于Object 包装的 BigInt, typeof() 方法返回 &quot;object&quot;, Object.prototype.toString.call() 方法返回 &quot;object BigInt&quot;\n&#x2F;&#x2F; typeCheck() 函数同样对于 Object 包装的 BigInt 返回 &quot;bigint&quot;\nconsole.log(typeof (Object(1n))); &#x2F;&#x2F; object\nconsole.log(Object(1n) instanceof Object);\nconsole.log(Object.prototype.toString.call(Object(1n))); &#x2F;&#x2F; &quot;object BigInt&quot;\nconsole.log(typeCheck(Object(1n))); &#x2F;&#x2F; bigint\nconsole.log(typeCheck(&#123;&#125;)); &#x2F;&#x2F; object\nconsole.log(typeCheck([])); &#x2F;&#x2F; array\nconsole.log(typeCheck(Boolean)); &#x2F;&#x2F; function\nconsole.log(typeCheck(Boolean())); &#x2F;&#x2F; boolean\nconsole.log(typeCheck(Boolean(1))); &#x2F;&#x2F; boolean\nconsole.log(typeCheck(new Boolean(1))); &#x2F;&#x2F; boolean\nconsole.log(typeCheck(Number)); &#x2F;&#x2F; function\nconsole.log(typeCheck(Number())); &#x2F;&#x2F; number\nconsole.log(typeCheck(Number(&quot;1&quot;))); &#x2F;&#x2F; number\nconsole.log(typeCheck(new Number(&quot;1&quot;))); &#x2F;&#x2F; number\nconsole.log(typeCheck(Symbol())); &#x2F;&#x2F; symbol\nconsole.log(typeof (Object(Symbol()))); &#x2F;&#x2F; object\nconsole.log(Object.prototype.toString.call(Object(Symbol()))); &#x2F;&#x2F; &quot;object Symbol&quot;\nconsole.log(typeCheck(Object(Symbol()))); &#x2F;&#x2F; symbol\nconsole.log(typeCheck(new Date())); &#x2F;&#x2F; date\nconsole.log(typeCheck(new RegExp())); &#x2F;&#x2F; regexp\nconsole.log(typeCheck(function () &#123; &#125;)); &#x2F;&#x2F; function\nconsole.log(typeCheck(new function () &#123; &#125;)); &#x2F;&#x2F; object\nconsole.log(typeCheck(function () &#123; return this; &#125;())); &#x2F;&#x2F; global (立即调用的未明确指定 this 值的函数表达式, 返回 global 全局对象)\nconsole.log(typeCheck(Math.sin)); &#x2F;&#x2F; function\nconsole.log(typeCheck(Math.sin())); &#x2F;&#x2F; number NaN\nconsole.log(typeCheck(Math.sin(1))); &#x2F;&#x2F; number\nconsole.log(typeCheck(class &#123;&#125;)); &#x2F;&#x2F; function\nconsole.log(typeCheck(class Person &#123;&#125;)); &#x2F;&#x2F; function\nconsole.log(typeCheck(new typeCheck())); &#x2F;&#x2F; object\nconsole.log(typeof(typeCheck(new typeCheck())) &#x3D;&#x3D;&#x3D; &quot;string&quot;); &#x2F;&#x2F; true\nconsole.log(Object.prototype.toString.call(new typeCheck())); &#x2F;&#x2F; &quot;object Object&quot;\nconsole.log(typeof(Object.prototype.toString.call(new typeCheck())) &#x3D;&#x3D;&#x3D; &quot;string&quot;); &#x2F;&#x2F; true</code></pre>\n","text":"类型校验函数的封装&#x2F;&#x2F; JavaScript 类型校验 checkType 函数, 返回值为字符串类型 function typeCheck(value) &#123; &#x2F;&#x2F; 1. null &#x2F;&#x2F; typeof() 方法...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","count":6,"path":"api/tags/JavaScript.json"},{"name":"类型校验","slug":"类型校验","count":1,"path":"api/tags/类型校验.json"},{"name":"封装函数","slug":"封装函数","count":1,"path":"api/tags/封装函数.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%A0%A1%E9%AA%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">类型校验函数的封装</span></a></li></ol>","author":{"name":"paranoia","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"https://321paranoiawhy.github.io","description":"生命不息, 笔耕不辍","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"LeetCode-796-Rotate-String","uid":"afa662091cf53ca79a8858de12df085e","slug":"LeetCode-796-Rotate-String","date":"2022-04-07T14:48:10.000Z","updated":"2022-04-07T18:29:10.931Z","comments":true,"path":"api/articles/LeetCode-796-Rotate-String.json","keywords":null,"cover":[],"text":" 题目描述LeetCode-796-Rotate-String Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s....","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","count":2,"path":"api/tags/LeetCode.json"}],"author":{"name":"paranoia","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"https://321paranoiawhy.github.io","description":"生命不息, 笔耕不辍","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"排序算法之JavaScript实现","uid":"0bbd469acde6df175f056490e56783a8","slug":"排序算法之JavaScript实现","date":"2022-03-30T08:29:25.000Z","updated":"2022-03-30T08:29:25.651Z","comments":true,"path":"api/articles/排序算法之JavaScript实现.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"paranoia","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"https://321paranoiawhy.github.io","description":"生命不息, 笔耕不辍","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}