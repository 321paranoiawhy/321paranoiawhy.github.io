[{"id":"efd5df9c3582a7fc2970cc06078f99a0","title":"使用Netlify实现自动化部署","content":"\n准备工作\n在 GitHub 上创建一个仓库\n\n将本地代码上传至该仓库# 在本地目录右键点击 Git Bash Here\n\n# 初始化本地仓库, 使其变成一个本地的 Git 仓库\ngit init # 本地目录下新增一个 .git 文件夹\n\n# 将本地目录所有文件添加到本地仓库\ngit add .\n\n# 将本地仓库的内容提交到本地仓库, 并添加注释\ngit commit -m &quot;This is a commit&quot;\n\n# 将本地仓库与 GitHub 远程仓库建立关联\ngit remote add origin https:&#x2F;&#x2F;github.com&#x2F;321paranoiawhy&#x2F;fenav.io\n\n# 若远程仓库不为空则必须进行这一步: 将本地仓库与远程仓库同步合并\ngit pull --rebase origin master\n\n# 将本地仓库内容推送到远程仓库\ngit push -u origin master\n\n# 状态查询\ngit status\n\n\n更新远程仓库后续本地仓库内容有修改时, 可以使用以下命令更新远程仓库:\ngit status\ngit add .\ngit commit -m &quot;This is a commit&quot;\ngit push origin master\n\n\nVue 项目设置在Vue项目中运行以下命令:\nnpm run serve\n# ctrl + C 停止服务\n\n# 生成 dist 文件夹\nnpm run build\n\n由于 vue 中 dist 文件夹默认情况下是被 git 忽略的, 所以需要在 .gitignore 文件中删去这一默认设置: 只需要找到 dist 并删除即可。\n\n使用 Netlify 实现自动部署使用 GitHub 连接并选择相应的仓库, 最后进行相应的设置即可成功部署。\nImport an existing project from a Git repository\n\n\n\n最后, 如果需要更改网站名称, 在 Site Settings 中修改 Site name 即可。\n\n\n\n","slug":"使用Netlify实现自动化部署","date":"2022-04-17T09:59:25.000Z","categories_index":"","tags_index":"Netlify,自动化部署,GitHub","author_index":"paranoia"},{"id":"0978c8b88ba6e3aab02deffaa34e6058","title":"文字滚动的实现","content":"文字横向滚动HTML 实现HTML 提供了 &lt;marquee&gt; 元素用以插入一段可滚动的文字。\n\n\n\n\n\n\n\n注意\n&lt;marquee&gt; 元素已过时,请不要再使用它。\nMDN-\nCan I use-HTML element: marquee\n\n&lt;!-- 默认效果 --&gt;\n&lt;marquee&gt;文字从左至右横向滚动&lt;&#x2F;marquee&gt;\n\n&lt;!-- direction&#x3D;&quot;up&quot; --&gt;\n&lt;marquee direction&#x3D;&quot;up&quot;&gt;文字从下至上竖向滚动&lt;&#x2F;marquee&gt;\n\n&lt;!-- 两层 marquee --&gt;\n&lt;!-- 类似电视机无信号或待机时的效果 --&gt;\n&lt;marquee direction&#x3D;&quot;down&quot; behavior&#x3D;&quot;alternate&quot;&gt;\n    &lt;marquee behavior&#x3D;&quot;alternate&quot;&gt;文字随机滚动&lt;&#x2F;marquee&gt;\n&lt;&#x2F;marquee&gt;\n\nCSS 实现JavaScript 实现第三方","slug":"文字滚动的实现","date":"2022-04-14T17:28:14.000Z","categories_index":"","tags_index":"JavaScript,文字滚动,实现,HTML,CSS","author_index":"paranoia"},{"id":"d59a8ff0fbd74225a125fea75d954925","title":"深入解析位运算性质","content":"\n二进制回顾十进制整数转换为二进制十进制整数转换为二进制可采用 除2取余, 逆序排列 (短除法) ：\n\n\n十进制小数转换为二进制十进制整数转换为二进制可采用 乘2取整, 顺序排列 ：\n以 0.625 为例:\n\n因此, 十进制 0.625 的二进制表示为: 0.101 。\n\n为何位运算尽管位运算在使用时存在表义不明的问题, 但只要加以适当注释, 就能解决这个问题。并且位运算基于数值的底层表示进行的, 速度快且效率高, 因而这里的一个最佳实践是:\n\n\n\n\n\n\n\n\n\n尽可能的使用位运算, 并加以适当的注释。\n\n位运算中的特殊值 NaN 和 Infinity\n按位非 ( ~ )按位非 ( ~ )用波浪符表示, 其返回数值的一补数 (反码): 将二进制表示上每一位 1 变成 0 , 每一位 0 变成 1 (按位取反)。\n// 对一个整数按位与, 相当于取相反数后再减去 1\nconsole.log(~1); // -2\nconsole.log(~(-1)); // 0\n\n// 对一个正数两次按位与, 向下取整, 等价于 Math.floor()\n// 对一个负数两次按位与, 向上取整, 等价于 Math.ceil()\nconsole.log(~~1.2); // 1\nconsole.log(Math.floor(1.2)); // 1\nconsole.log(~~(-1.2)); // -1\nconsole.log(Math.ceil(-1.2)); // -1\n\n// Mth.round() 返回数值的四舍五入 (最接近的整数)\nconsole.log(Math.round(1.2)); // 1\nconsole.log(Math.round(1.8)); // 2\nconsole.log(Math.round(-1.2)); // -1\nconsole.log(Math.round(-1.8)); // -2\n\n\na &amp; (~1)// a &amp; (~1)\n// 将 a 的整数部分取出, 并将最后一位变成 0\n// 如果 a 的第 0 位是 1, 则 a &amp; (~1) 等价于 a - 1\nconsole.log(3 &amp; (~1)); // 2 (11 -&gt; 10)\nconsole.log(5 &amp; (~1)); // 4 (101 -&gt; 100)\nconsole.log(7 &amp; (~1)); // 6 (111 -&gt; 110)\n// 如果 a 的第 0 位是 0, 则 a &amp; (~1) 等价于 a\nconsole.log(8 &amp; (~1)); // 8 (1000 -&gt; 1000)\n\n// a 为小数且为正时, a &amp; (~1) 等价于 Math.floor(a) &amp; (~1)\nconsole.log(8.2 &amp; (~1)); // 8\nconsole.log(Math.floor(8.2) &amp; (~1)); // 8\nconsole.log(8.8 &amp; (~1)); // 8\nconsole.log(Math.floor(8.8) &amp; (~1)); // 8\n// a 为小数且为负时, a &amp; (~1) 等价于 Math.ceil(a) &amp; (~1)\nconsole.log(-8.2 &amp; (~1)); // -8\nconsole.log(Math.ceil(-8.2) &amp; (~1)); // -8\nconsole.log(-8.8 &amp; (~1)); // -8\nconsole.log(Math.ceil(-8.8) &amp; (~1)); // -8\n\n\n~ a+ 1 (a 的相反数)console.log(~1 + 1); // -1\nconsole.log(~1.2 + 1); // -1\nconsole.log(~1.8 + 1); // -1\nconsole.log(~(-1) + 1); // 1\nconsole.log(~(-1.2) + 1); // 1\nconsole.log(~(-1.8) + 1); // 1\n\n\n按位与 ( &amp; )\na &amp; 0 ===0任何数同 0 按位与都等于 0 。\nconsole.log(1 &amp; 0); // 0\nconsole.log(2 &amp; 0); // 0\n\n\na &amp; 1 (结果为 0 或 1)由于 1 的二进制表示中第 0 位为 1 , 其余位均为 0 , 则任何一个数与 1 按位与, 其结果第 0 位取决于该数的第 0 位是否为 1 , 结果的其余位则均为 0 。因而任何一个数同 1 按位与的结果只可能是 0 或 1 , 也可以借助这一特性判断一个数的第 0 位是否为 1 。\nconsole.log(0 &amp; 1); // 0 (0 -&gt; 0)\nconsole.log(1 &amp; 1); // 1 (1 -&gt; 1)\nconsole.log(2 &amp; 1); // 0 (10 -&gt; 00)\nconsole.log(3 &amp; 1); // 1 (11 -&gt; 01)\nconsole.log(4 &amp; 1); // 0 (100 -&gt; 000)\n\n更进一步, 如果一个数同 1 按位与的结果是 0 , 则将该数左移一位; 如果该数同 1 按位与的结果是 1 , 则 将该数左移一位同时计数器加 1; 重复以上操作直到该数变成 0 , 便可统计出该数二进制中 1 的个数。\nfunction hammingWeight(number) {\n    let count = 0;\n    while (number) {\n        number &amp; 1 === 1 ? (count += 1, number = number &gt;&gt; 1) : (number = number &gt;&gt; 1)\n    }\n    return count;\n}\nconsole.log(hammingWeight(11)); // 3\nconsole.log(hammingWeight(128)); // 1\nconsole.log(hammingWeight(11111111)); // 12\n\n// 这里存在一个待解决的 bug: 无法运算(陷入无限循环)\n// 4294967293 &amp; 1 -&gt; 1, 4294967293 &gt;&gt; 1 -&gt; -2\n// -2 &amp; 1 -&gt; 0, -2 &gt;&gt; 1 -&gt; -1\n// -1 &amp; 1 -&gt; 1, -1 &gt;&gt; 1 -&gt; -1\n// -1 &amp; 1 -&gt; 1, -1 &gt;&gt; 1 -&gt; -1\n// ...\n// console.log(hammingWeight(4294967293));\n// 其原因为: 对一个很大的数进行左移操作可能出现负值(4294967293 &gt;&gt; 1 -&gt; -2), 从而导致无限循环\n\n\na &amp; (a - 1)将任意一个数同其减去1之后的数按位与, 结果等价于将原来的数的二进制表示中最后一个 1 变成 0 。\n// 以 27(11011) 为例\nconsole.log(27 &amp; (27 - 1)); // 26 (11011 -&gt; 11010)\nconsole.log(26 &amp; (26 - 1)); // 24 (11010 -&gt; 11000)\nconsole.log(24 &amp; (24 - 1)); // 16 (11000 -&gt; 10000)\nconsole.log(16 &amp; (16 - 1)); // 0 (10000 -&gt; 00000)\n\n若对一个数不断重复上述操作直到该数变为 0 , 并使用计数器便可得到该数的二进制表示中 1 的个数。\nfunction hammingWeight(number) {\n    let count = 0;\n    while (number) {\n        number = number &amp; (number - 1);\n        count++;\n    }\n    return count;\n}\nconsole.log(hammingWeight(27)); // 4 (11011 -&gt; 11010 -&gt; 11000 -&gt; 10000 -&gt; 00000)\n\nRead Also:\n快速计算一个正二进制数中包含多少个1\n另外, 还可判断一个数是否为 2 的幂:\n// 判断一个数是否为 2 的幂\n// 若是, 返回一个数组, 第一个元素 true 表示是, 第二个元素表示幂次\n// 若不是, 返回一个数组, 第一个元素 false 表示否, 第二个元素固定 -1 表示该数不是 2 的幂\nfunction powerOfTwo(number) {\n    return (number &amp; (number - 1)) === 0 ? [true, number.toString(2).length - 1] : [false, -1];\n}\nconsole.log(powerOfTwo(1)); // [true, 0]\nconsole.log(powerOfTwo(4)); // [true, 2] 2 * *2 =4\nconsole.log(powerOfTwo(1000)); // [false, -1]\nconsole.log(powerOfTwo(1024)); // [true, 10] 2 ** 10 = 1024\n\nRead Also:\n判断是否为 2 的 N 次方\n\na &amp; (-a) (获取 a 的最大的2整次幂约数)console.log(12 &amp; -12); // 4 (2**2)\nconsole.log(16 &amp; -16); // 16 (2**4)\nconsole.log(108 &amp; -108); // 4 (2**2)\n\n\n最大公约 (因) 数和最小公倍数// greatest common divisor\n// 递归求两数的最大公约数 gcm\nfunction gcd(a, b) {\n    if (b === 0) return a;\n    return gcd(b, a % b);\n}\nconsole.log(gcd(12, 8)); // 4\n// gcd(0, 8) = gcd(8, 0) = 8\nconsole.log(gcd(0, 8)); // 8\nconsole.log(gcd(8, 0)); // 8\n// least common multiple\n// 最小公倍数为两数之积除以两数最大公约数 lcm\nfunction lcm(a, b) {\n    return a * b / gcd(a, b);\n}\nconsole.log(lcm(12, 8)); // 24\n\n这里, 对于 gcd 和 lcm 的定义, 可以参考 wiki 。\n关于 gcd(0, 8) = gcd(8, 0) = 8, 可参考 这里\n\n按位或 ( | )按位异或 ( ^ )左移 ( &lt;&lt; )> )\">有符号右移 ( &gt;&gt; )>> )\">无符号右移 ( &gt;&gt;&gt; )为何左移不区分为有符号左移和无符号左移?","slug":"深入解析位运算性质","date":"2022-04-12T09:29:31.000Z","categories_index":"","tags_index":"位运算,深入解析","author_index":"paranoia"},{"id":"1001f33dad10400ea5f367d8a08e122a","title":"精确覆盖问题","content":"\n精确覆盖问题Exact cover wiki\nDancing Links OI Wiki\nA Sudoku Solver in Java implementing Knuth’s Dancing Links Algorithm\n\n数独规则回顾\n每个格子只能填入 1 ~ 9 中的一个数字;\n每行 1 ~ 9 中的每个数字只能出现一次;\n每列 1 ~ 9 中的每个数字只能出现一次;\n每宫 1 ~ 9 中的每个数字只能出现一次。\n\n\n矩阵列定义 (约束条件)将矩阵的每一列均定义为一个约束条件。\n\n第 1 ~ 81 列9 x 9 的数独一共有 81 个格子, 于是定义对应的 81 列:\n第 1 列表示数独第 1 行第 1 列 (1, 1) 处填入了一个数字;\n第 2 列表示数独第 1 行第 2 列 (1, 2) 处填入了一个数字;\n第 3 列表示数独第 1 行第 3 列 (1, 3) 处填入了一个数字;\n……\n第 9 列表示数独第 1 行第 9 列 (1, 9) 处填入了一个数字;\n第 10 列表示数独第 2 行第 1 列 (2, 1) 处填入了一个数字;\n第 11 列表示数独第 2 行第 2 列 (2, 2) 处填入了一个数字;\n……\n第 18 列表示数独第 2 行第 9 列 (2, 9) 处填入了一个数字;\n……\n第 81 列表示数独第 9 行第 9 列 (9, 9) 处填入了一个数字;\n此即: 第 N(1 ~ 81) 列表示数独第 X 行第 Y 列 (X, Y) 处填入了一个数字, 其中:\nX &#x3D; Math.floor((N - 1) &#x2F; 9) + 1;\nY &#x3D;(N - 1) % 9 + 1;\nN &#x3D; (X - 1) * 9 + Y;\n\n\n第 82 ~ 2 x 81(162) 列第 82 列表示数独第 1 行填入了数字 1;\n第 83 列表示数独第 1 行填入了数字 2;\n第 84 列表示数独第 1 行填入了数字 3;\n……\n第 90 列表示数独第 1 行填入了数字 9;\n第 91 列表示数独第 2 行填入了数字 1;\n第 92 列表示数独第 2 行填入了数字 2;\n……\n第 99 列表示数独第 2 行填入了数字 9;\n……\n第 162 列表示数独第 9 行填入了数字 9;\n此即: 第 N(82 ~ 162) 列表示数独第 X(1 ~ 9) 行填入了数字 Y(1 ~ 9), 其中:\n&#x2F;&#x2F; N -&gt; N - 81\nX &#x3D; Math.floor((N - 81 - 1) &#x2F; 9) + 1;\nY &#x3D;(N - 81 - 1) % 9 + 1;\nN - 81 &#x3D; (X - 1) * 9 + Y;\n\n\n第 163 ~ 3 x 81(243) 列第 163 列表示数独第 1 列填入了数字 1;\n第 164 列表示数独第 1 列填入了数字 2;\n第 165 列表示数独第 1 列填入了数字 3;\n……\n第 171 列表示数独第 1 列填入了数字 9;\n第 172 列表示数独第 2 列填入了数字 1;\n第 173 列表示数独第 2 列填入了数字 2;\n……\n第 180 列表示数独第 2 列填入了数字 9;\n……\n第 243 列表示数独第 9 列填入了数字 9;\n此即: 第 N(163 ~ 243) 列表示数独第 X(1 ~ 9) 列填入了数字 Y(1 ~ 9), 其中:\n&#x2F;&#x2F; N -&gt; N - 162\nX &#x3D; Math.floor((N - 162 - 1) &#x2F; 9) + 1;\nY &#x3D;(N - 162 - 1) % 9 + 1;\nN - 162 &#x3D; (X - 1) * 9 + Y;\n\n\n第 244 ~ 4 x 81(324) 列第 244 列表示数独第 1 宫填入了数字 1;\n第 245 列表示数独第 1 宫填入了数字 2;\n第 246 列表示数独第 1 宫填入了数字 3;\n……\n第 252 列表示数独第 1 宫填入了数字 9;\n第 253 列表示数独第 2 宫填入了数字 1;\n第 254 列表示数独第 2 宫填入了数字 2;\n……\n第 261 列表示数独第 2 宫填入了数字 9;\n……\n第 324 列表示数独第 9 宫填入了数字 9;\n此即: 第 N(163 ~ 324) 列表示数独第 X(1 ~ 9) 宫填入了数字 Y(1 ~ 9), 其中:\n&#x2F;&#x2F; N -&gt; N - 243\nX &#x3D; Math.floor((N - 243 - 1) &#x2F; 9) + 1;\nY &#x3D;(N - 243 - 1) % 9 + 1;\nN - 243 &#x3D; (X - 1) * 9 + Y;\n\n\n矩阵构建\n有数字的格子以数独第 4 行第 2 列 (4, 2) 处填入数字 7 为例:\n\n(4, 2) 处填入了一个数字;\n第 4 列处填入了一个数字 7;\n第 2 行处填入了一个数字 7;\n第 4 宫处填入了一个数字 7;\n\n这里, 由坐标 (X, Y) 计算所在宫 N(1 ~ 9) 的公式为:\n&#x2F;&#x2F; (X, Y, N) 表示 X 行 Y 列位于宫 N\n&#x2F;&#x2F; 第 1 宫第 1 行 (1, 1, 1), (1, 2, 1), (1, 3, 1)\n&#x2F;&#x2F; 第 1 宫第 2 行 (2, 1, 1), (2, 2, 1), (2, 3, 1)\n&#x2F;&#x2F; 第 1 宫第 3 行 (3, 1, 1), (3, 2, 1), (3, 3, 1)\n\n&#x2F;&#x2F; 第 2 宫第 1 行 (1, 4, 2), (1, 5, 2), (1, 6, 2)\n&#x2F;&#x2F; 第 2 宫第 2 行 (2, 4, 2), (2, 5, 2), (2, 6, 2)\n&#x2F;&#x2F; 第 2 宫第 3 行 (3, 4, 2), (3, 5, 2), (3, 6, 2)\n\n\n&#x2F;&#x2F; 第 3 宫第 1 行 (1, 7, 3), (1, 8, 3), (1, 9, 3)\n&#x2F;&#x2F; 第 3 宫第 2 行 (2, 7, 3), (2, 8, 3), (2, 9, 3)\n&#x2F;&#x2F; 第 3 宫第 3 行 (2, 7, 3), (2, 8, 3), (2, 9, 3)\n\n&#x2F;&#x2F; 第 4 宫第 2 行 (4, 1, 4), (4, 2, 4), (4, 3, 4)\n&#x2F;&#x2F; (4, 2) 位于 第 4 宫\n\nN &#x3D; Math.floor((X - 1)) &#x2F; 3 * 3 + Math.floor((Y - 1)) &#x2F; 3 + 1;\n\n对应的矩阵列定义为:\n\n(4, 2) 处填入了一个数字: 对应的矩阵列 N 为 (4 - 1) * 9 + 2 &#x3D; 29;\n第 4 列处填入了一个数字 7: 对应的矩阵列 N 为 (4 - 1) * 9 + 7 + 81 &#x3D; 115;\n第 2 行处填入了一个数字 7: 对应的矩阵列 N 为 (2 - 1) * 9 + 7 + 162 &#x3D; 178;\n第 4 宫处填入了一个数字 7: 对应的矩阵列 N 为 (4 - 1) * 9 + 7 + 243 &#x3D; 277.\n\n于是, (4, 2) 处填入数字 7, 转换成矩阵的一行: 第 29 列、第 115 列、第 178 列和第 277 列为 1, 其余列为 0.\n\n无数字的格子以数独第 5 行第 8 列 (5, 8) 处未填入数字为例:\n\n(5, 8) 处填入数字 1, 转换成矩阵的一行为: 第 44 列、第 118 列、第 226 列和第 289 列为 1, 其余列为 0.\n(5, 8) 处填入数字 2, 转换成矩阵的一行为: 第 44 列、第 119 列、第 227 列和第 290 列为 1, 其余列为 0.\n(5, 8) 处填入数字 3, 转换成矩阵的一行为: 第 44 列、第 120 列、第 228 列和第 291 列为 1, 其余列为 0.\n(5, 8) 处填入数字 4, 转换成矩阵的一行为: 第 44 列、第 121 列、第 229 列和第 292 列为 1, 其余列为 0.\n(5, 8) 处填入数字 5, 转换成矩阵的一行为: 第 44 列、第 122 列、第 230 列和第 293 列为 1, 其余列为 0.\n(5, 8) 处填入数字 6, 转换成矩阵的一行为: 第 44 列、第 123 列、第 231 列和第 294 列为 1, 其余列为 0.\n(5, 8) 处填入数字 7, 转换成矩阵的一行为: 第 44 列、第 124 列、第 232 列和第 295 列为 1, 其余列为 0.\n(5, 8) 处填入数字 8, 转换成矩阵的一行为: 第 44 列、第 125 列、第 233 列和第 296 列为 1, 其余列为 0.\n(5, 8) 处填入数字 9, 转换成矩阵的一行为: 第 44 列、第 126 列、第 234 列和第 297 列为 1, 其余列为 0.\n\n将以上 9 行插入到矩阵中, 可以发现矩阵第 44 列全为 1, 其余列则不可能全为 1, 因此这 9 行必选中其中一行, 由精确覆盖问题的定义可知: 该选中的行即为最后解的其中一行, 也即: 数独 (5, 8) 处必填入了 1 ~ 9 其中一个数字。\n\n数独转换为矩阵对于数独中每一个格子, 不论其是否有数字, 均可由上述两条规则转换为矩阵中的行: 1 ~ 9 行。\n\n精确覆盖问题的求解","slug":"精确覆盖问题","date":"2022-04-12T09:10:46.000Z","categories_index":"","tags_index":"","author_index":"paranoia"},{"id":"6476889812499529d67e180547b73424","title":"LeetCode-剑指Offer-15-二进制中1的个数","content":"\n题目描述本题同 LeetCode-191-位1的个数。\n编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 Hamming weight )。\n示例1\n输入：n &#x3D; 11 (控制台输入 00000000000000000000000000001011)\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有 3 位为 &#39;1&#39;。\n\n示例2\n输入：n &#x3D; 128 (控制台输入 00000000000000000000000010000000)\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有 1 位为 &#39;1&#39;。\n\n示例3\n输入：n &#x3D; 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n &#x3D; -3）\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。\n\n提示:\n输入必须是长度为 32 的 二进制串 。\n\n暴力循环function hammingWeight(number) &#123;\n    &#x2F;&#x2F; 数字转换为二进制下的字符串\n    number &#x3D; number.toString(2);\n    let count &#x3D; 0;\n    &#x2F;&#x2F; 遍历字符串\n    for (let i &#x3D; 0; i &lt; number.length; i++) &#123;\n        &#x2F;&#x2F; 使用 charAt() 方法获取字符串中的每一个字符\n        &#x2F;&#x2F; 注意与 字符串 1 比较, 而不是数字 1\n        if (number.charAt(i) &#x3D;&#x3D;&#x3D; &quot;1&quot;) &#123;\n            count +&#x3D; 1;\n        &#125;\n    &#125;\n    return count;\n&#125;\nconsole.log(hammingWeight(11)); &#x2F;&#x2F; 3\nconsole.log(hammingWeight(128)); &#x2F;&#x2F; 1\nconsole.log(hammingWeight(4294967293)); &#x2F;&#x2F; 31\n\n按位与按位与操作符将两个二进制数的每一位对齐, 当且仅当某位上均为 1 时该位结果为 1, 否则为 0。例如:1 的二进制表示为 1 , 2 的二进制表示为 10 , 3 的二进制表示为 11 , 4 的二进制表示为 100 , 因此有以下结果:\n1&amp;1 = 1, 2&amp;1=0, 3&amp;1=1, 4&amp;1=0\n由于 1 的二进制表示中仅有第 0 位为 1 , 所以, 任何一个数与 1 按位与时, 第 0 位之前所有位都将为 0 , 第 0 位结果则取决于这个数第 0 位是否为 1 : 第 0 位为 1 时, 结果为 1 , 否则为 0 。\n&#x2F;&#x2F; a &amp; 1\nfunction hammingWeight(number) &#123;\n    let count &#x3D; 0;\n    for (let i &#x3D; 0; i &lt; 32; i++) &#123;\n        &#x2F;&#x2F; if (number &amp; 1 &#x3D;&#x3D;&#x3D; 1) &#123;\n        &#x2F;&#x2F;     count +&#x3D; 1;\n        &#x2F;&#x2F;     number &#x3D; number &gt;&gt; 1;\n        &#x2F;&#x2F; &#125;\n        &#x2F;&#x2F; else &#123; number &#x3D; number &gt;&gt; 1; &#125;\n        number &amp; 1 &#x3D;&#x3D;&#x3D; 1 ? (count +&#x3D; 1, number &#x3D; number &gt;&gt; 1) : (number &#x3D; number &gt;&gt; 1)\n    &#125;\n    return count;\n&#125;\n\n&#x2F;&#x2F; a &amp; (a - 1)\nfunction hammingWeight(number) &#123;\n    let count &#x3D; 0;\n    while (number) &#123;\n        number &#x3D; number &amp; (number - 1);\n        count++;\n    &#125;\n    return count;\n&#125;\nconsole.log(hammingWeight(27)); &#x2F;&#x2F; 4 (11011 -&gt; 11000 -&gt; 10000 -&gt; 00000)\n\n","slug":"LeetCode-剑指Offer-15-二进制中1的个数","date":"2022-04-11T13:15:22.000Z","categories_index":"","tags_index":"LeetCode,剑指Offer,二进制","author_index":"paranoia"},{"id":"91d29442500deeb82a763ac9ac0b6005","title":"JavaScript数组之奇技淫巧","content":"\n快速创建有规律数组\n元素为 0 ~ 99 的数组&#x2F;&#x2F; new Array(100) 创建一个长度为 100 的空数组 (new 关键字可省略)\n&#x2F;&#x2F; keys() 返回数组索引的一个迭代器\n&#x2F;&#x2F; Array.from() 将迭代器 (类数组对象, 任何可迭代对象) 转换为数组实例\nArray.from(new Array(100).keys()); &#x2F;&#x2F; 0 ~ 99\n\n\n元素为 1 ~ 100 的数组&#x2F;&#x2F; new Array(100) 创建一个长度为 100 的空数组 (new 关键字可省略)\n&#x2F;&#x2F; keys() 返回数组索引的一个迭代器\n&#x2F;&#x2F; Array.from() 将迭代器 (类数组对象, 任何可迭代对象) 转换为数组实例\n&#x2F;&#x2F; map() 对数组的每个元素执行指定的操作: 箭头函数\nArray.from(new Array(100).keys()).map(i &#x3D;&gt; i + 1); &#x2F;&#x2F; 1 ~ 100\n\n&#x2F;&#x2F; 在 Array.from() 中使用箭头函数\n&#x2F;&#x2F;\nArray.from(new Array(100), (item, index) &#x3D;&gt; index + 1); &#x2F;&#x2F; 1 ~ 100\n\n\n元素为指定区间 [start, end] 的数组&#x2F;&#x2F; slice() 方法\nlet start &#x3D; 3;\nlet end &#x3D; 10;\nArray.from(new Array(end + 1).keys()).slice(start); &#x2F;&#x2F; [3, 4, 5, 6, 7, 8, 9, 10]\n\n&#x2F;&#x2F; 更为通用的方法\nfunction range(start, end, step) &#123;\n    return Array.from(&#123; length: (end - start) &#x2F; step + 1 &#125;, (v, i) &#x3D;&gt; start + i * step);\n&#125;\nconsole.log(range(10, 100, 10)); &#x2F;&#x2F; [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\nconsole.log(range(0, 4, 1)); &#x2F;&#x2F; [0, 1, 2, 3, 4]\nconsole.log(range(1, 10, 2)); &#x2F;&#x2F; [1, 3, 5, 7, 9]\n\n&#x2F;&#x2F; 直接写成箭头函数\nconst arrowRange &#x3D; (start, end, step) &#x3D;&gt; Array.from(&#123; length: (end - start) &#x2F; step + 1 &#125;, (v, i) &#x3D;&gt; start + i * step);\n元素为字母表的数组const arrowRange &#x3D; (start, end, step) &#x3D;&gt; Array.from(&#123; length: (end - start) &#x2F; step + 1 &#125;, (v, i) &#x3D;&gt; start + i * step);\n\n&#x2F;&#x2F; 大写字母表 Alphabet 字符数组\nlet Alphabet &#x3D; arrowRange(&quot;A&quot;.charCodeAt(0), &quot;Z&quot;.charCodeAt(0), 1).map(i &#x3D;&gt; String.fromCharCode(i));\nconsole.log(Alphabet);\n&#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;,&#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;,&#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;,&#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39; &#39;Y&#39;, &#39;Z&#39;]\n\n&#x2F;&#x2F; 小写字母表 alphabet 字符数组\nlet alphabet &#x3D; arrowRange(&quot;a&quot;.charCodeAt(0), &quot;z&quot;.charCodeAt(0), 1).map(i &#x3D;&gt; String.fromCharCode(i));\nconsole.log(alphabet);\n&#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;,&#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;,&#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;,&#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39; &#39;y&#39;, &#39;z&#39;]\n\n&#x2F;&#x2F; number 为元素为 0~9 的字符数组\nlet number &#x3D; arrowRange(0, 9, 1).map(i &#x3D;&gt; i + &quot;&quot;);\nconsole.log(number);\n&#x2F;&#x2F; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n&#x2F;&#x2F; 十六进制下字符数组 Digits (0~9, A~Z, 共10+26&#x3D;36个)\nlet Digits &#x3D; number.concat(Alphabet);\nconsole.log(Digits);\n&#x2F;&#x2F; [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;,&#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;,&#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;,&#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;,&#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;,&#39;Z&#39;]\n\n&#x2F;&#x2F; 十六进制下字符串 DigitsString (0~9, A~Z, 共10+26&#x3D;36个)\nlet DigitsString &#x3D; (number + &quot;&quot; + Alphabet).replace(&#x2F;,&#x2F;g, &quot;&quot;);\nconsole.log(DigitsString);\n&#x2F;&#x2F; &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;\n\n&#x2F;&#x2F; 十六进制下字符数组 digits (0~9, a~z, 共10+26&#x3D;36个)\nlet digits &#x3D; number.concat(alphabet);\nconsole.log(digits);\n&#x2F;&#x2F; [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;,&#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;,&#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;,&#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;,&#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;,&#39;z&#39;]\n\n&#x2F;&#x2F; 十六进制下字符串 digitsString (0~9, a~z, 共10+26&#x3D;36个)\nlet digitsString &#x3D; (number + &quot;&quot; + alphabet).replace(&#x2F;,&#x2F;g, &quot;&quot;);\nconsole.log(digitsString);\n&#x2F;&#x2F; &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;\n\n\n数组去重function combine()&#123;\n    let arr &#x3D; [].concat.apply([], arguments);  &#x2F;&#x2F; 没有去重复的新数组\n    return Array.from(new Set(arr));\n&#125;\nconsole.log(combine([1, 2, 3], [4, 5, 6])); &#x2F;&#x2F; [1, 2, 3, 4, 5, 6]\nconsole.log(combine([2, 2, 2], [2, 3, 3])); &#x2F;&#x2F; [2, 3]\n\n\n","slug":"JavaScript数组之奇技淫巧","date":"2022-04-11T11:22:17.000Z","categories_index":"","tags_index":"JavaScript,数组,奇技淫巧","author_index":"paranoia"},{"id":"145ad428fef705684e91c950833ed83f","title":"数独游戏设计与实现","content":"\n数独简介数独起源数独分类\n\n河图洛书\n\n -->\n\n\n射雕英雄传\n\n\n\n\n\n\n\n\n那女子沮丧失色, 身子摇了几摇, 突然一交跌在细沙之中, 双手捧头, 苦苦思索, 过了一会, 忽然抬起头来, 脸有喜色, 道：“你的算法自然精我百倍, 可是我问你：将一至九这九个数字排成三列, 不论纵横斜角, 每三字相加都是十五, 如何排法？”黄蓉心想：“我爹爹经营桃花岛, 五行生克之变, 何等精奥？这九宫之法是桃花岛阵图的根基, 岂有不知之理？”当下低声诵道：“九宫之义, 法以灵龟, 二四为肩, 六八为足, 左三右七, 戴九履一, 五居中央。”边说边画, 在沙上画了一个九宫之图。那女子面如死灰, 叹道：“只道这是我独创的秘法, 原来早有歌诀传世。”\n注意这里的 二四为肩, 六八为足 是从右往左的顺序, 因此黄蓉所说的九宫幻方第一行为 4, 9, 2; 第二行为 3, 5, 7; 第三行为 8, 1, 6:\n\n接着, 黄蓉继续介绍了四四图:\n\n\n\n\n\n\n\n\n\n那女子面如死灰, 叹道：“只道这是我独创的秘法, 原来早有歌诀传世。”黄蓉笑道：“不但九宫, 即使四四图, 五五图, 以至百子图, 亦不足为奇。就说四四图罢, 以十六字依次作四行排列, 先以四角对换, 一换十六, 四换十三, 后以内四角对换, 六换十一, 七换十。这般横直上下斜角相加, 皆是三十四。”那女子依法而画, 果然丝毫不错。\n以十六字依次作四行排列:\n\n先以四角对换, 一换十六, 四换十三:\n\n后以内四角对换, 六换十一, 七换十:\n\n由此得到的 4 x 4 幻方各行各列及两对角线数字之和均为 \n说完这些, 黄蓉又继续介绍:\n\n\n\n\n\n\n\n\n\n黄蓉道：“那九宫每宫又可化为一个八卦，八九七十二数，以从一至七十二之数，环绕九宫成圈，每圈八字，交界之处又有四圈，一共一十三圈，每圈数字相加，均为二百九十二。这洛书之图变化神妙如此，谅你也不知晓。”举手之间，又将七十二数的九宫八卦图在沙上画了出来。\n这里略微复杂, 有兴趣的读者可以自行研究。\n\n9 x 9 标准数独标准数独即满足数独规则且仅有唯一解的数独。\n\n数独规则\n数独中会给定一定数量、混乱的初始数字 (亦称提示数);\n每个格子只能填入 1 ~ 9 之间的数字;\n每一行、每一列、每一宫中的数字各不相同, 即 9 个格子中的数正好满射于 1~9 之间。\n\n\n数独的等价变换\n行与行互换 (一次或任意多次)\n列与列互换 (一次或任意多次)\n数字 1 ~ 9 的变换, 如将 [1, 2, 3, 4, 5, 6, 7, 8, 9] 变换为 [2, 3, 4, 5, 6, 7, 8, 9, 1] (1 对应 2, 2 对应 3, …, 9 对应 1)\n数独整体变换(旋转、镜像等), 如顺时针旋转 90°, 以右边界做镜像\n\n排除等价的数独后, 剩下 5,475,730,538 个等价类。\n\n数独多解情形\n连续三行、连续三列和连续三宫均无初始数字的数独必多解;\n初始数字缺少 1 ~ 9 中两个及以上数字的数独必多解;\n空白行、空白列和空白宫 (不一定连续) 的数量超过 5 的数独必多解。\n\n\n数独无解情形\n数独有解最少初始数字对于 9 x 9 的标准数独, 至少需要 17 个初始数字, 详细证明见下面的论文:\nSudoku Checker and the Minimum Number of Clues Problem\n也即:给定 16 个初始数字的 9 x 9 标准数独均无解。对于给定16 个初始数字的 9 x 9 标准数独的等价类, 共有 = 33594090947249085 种可能, 要验证每一个等价类均无解, 这是很困难的。\n\n快速设计数独按以下步骤可以快速设计一个满足条件的数独:\n\n对 1 ~ 9 乱序排列得到一个数组 array;\n数独第一行第 i 列的数字是 array[i], i = 1..9;\n数独第二行第 i 列的数字是 array[i + 1], i = 1..8, 数独第二行第九列的数字为 array[0];\n数独第三行第 i 列的数字是 array[i + 2], i = 1..7, 数独第三行第八列和第九列的数字分别为 array[0] 和 array[1];\n…\n数独第九行第 i 列的数字是 array[i + 8], i = 1..6, 数独第九行第七列和第八列的数字分别为 array[0] 和 array[1];\n\n更多细节可参考下书:\nCreate Classic Sudoku: Make Your Own in Minutes\n\n数独实用技巧\n数独的设计与实现数独是NP完全问题\n创建可视化布局\n","slug":"数独游戏设计与实现","date":"2022-04-10T07:54:35.000Z","categories_index":"","tags_index":"JavaScript,数独,suduku,设计与实现","author_index":"paranoia"},{"id":"10790f82c593c2090a644c2eb357ae58","title":"pip安装第三方库报错","content":"\n报错示意# 安装第三方库 manim\n# 注意 package_name 为 manimgl (而非 manim)\npip install manimgl\n\nWARNING: Retrying (Retry(total&#x3D;4, connect&#x3D;None, read&#x3D;None, redirect&#x3D;None, status&#x3D;None)) after connection broken by &#39;SSLError(SSLEOFError(8, &#39;EOF occurred in violation of protocol (_ssl.c:997)&#39;))&#39;: &#x2F;simple&#x2F;manimgl&#x2F;\nWARNING: Retrying (Retry(total&#x3D;3, connect&#x3D;None, read&#x3D;None, redirect&#x3D;None, status&#x3D;None)) after connection broken by &#39;SSLError(SSLEOFError(8, &#39;EOF occurred in violation of protocol (_ssl.c:997)&#39;))&#39;: &#x2F;simple&#x2F;manimgl&#x2F;\nWARNING: Retrying (Retry(total&#x3D;2, connect&#x3D;None, read&#x3D;None, redirect&#x3D;None, status&#x3D;None)) after connection broken by &#39;SSLError(SSLEOFError(8, &#39;EOF occurred in violation of protocol (_ssl.c:997)&#39;))&#39;: &#x2F;simple&#x2F;manimgl&#x2F;\nWARNING: Retrying (Retry(total&#x3D;1, connect&#x3D;None, read&#x3D;None, redirect&#x3D;None, status&#x3D;None)) after connection broken by &#39;SSLError(SSLEOFError(8, &#39;EOF occurred in violation of protocol (_ssl.c:997)&#39;))&#39;: &#x2F;simple&#x2F;manimgl&#x2F;\nWARNING: Retrying (Retry(total&#x3D;0, connect&#x3D;None, read&#x3D;None, redirect&#x3D;None, status&#x3D;None)) after connection broken by &#39;SSLError(SSLEOFError(8, &#39;EOF occurred in violation of protocol (_ssl.c:997)&#39;))&#39;: &#x2F;simple&#x2F;manimgl&#x2F;\nCould not fetch URL https:&#x2F;&#x2F;pypi.org&#x2F;simple&#x2F;manimgl&#x2F;: There was a problem confirming the ssl certificate: HTTPSConnectionPool(host&#x3D;&#39;pypi.org&#39;, port&#x3D;443): Max retries exceeded with url: &#x2F;simple&#x2F;manimgl&#x2F; (Caused by SSLError(SSLEOFError(8, &#39;EOF occurred in violation of protocol (_ssl.c:997)&#39;))) - skipping\nERROR: Could not find a version that satisfies the requirement manimgl (from versions: none)\nERROR: No matching distribution found for manimgl\n\n\n报错原因及解决方法源地址无法链接上, 可以手动更换镜像源:\n&lt;!-- 阿里云 --&gt;\nhttp:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;\n&lt;!-- 中国科技大学 --&gt;\nhttps:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;\n&lt;!-- 豆瓣 --&gt;\nhttp:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;\n&lt;!-- 清华大学 --&gt;\nhttps:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;\n&lt;!-- 中国科学技术大学 --&gt;\nhttp:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;\n\n\n\n\n\n\n\n提示\n挂 VPN 也可能出现同样的问题\n\n须将执行命令做相应更改:\n&lt;!-- 以阿里云镜像源为例 --&gt;\npip install package_name -i http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F; --trusted-host mirrors.aliyun.com\n&lt;!-- 省略中间安装过程 --&gt;\n...\n&lt;!-- 安装成功提示 --&gt;\nSuccessfully installed Pillow-9.1.0 PyOpenGL-3.1.6 asttokens-2.0.5 backcall-0.2.0 colorama-0.4.4 colour-0.1.5 commonmark-0.9.1 cycler-0.11.0 decorator-5.1.1 executing-0.8.3 fonttools-4.32.0 glcontext-2.3.5 ipython-8.2.0 isosurfaces-0.1.0 jedi-0.18.1 kiwisolver-1.4.2 manimgl-1.6.0 manimpango-0.4.1 mapbox-earcut-1.0.0 matplotlib-3.5.1 matplotlib-inline-0.1.3 moderngl-5.6.4 moderngl-window-2.4.1 mpmath-1.2.1 multipledispatch-0.6.0 packaging-21.3 parso-0.8.3 pickleshare-0.7.5 prompt-toolkit-3.0.29 pure-eval-0.2.2 pydub-0.25.1 pyglet-1.5.23 pygments-2.11.2 pyparsing-3.0.7 pyrr-0.10.3 python-dateutil-2.8.2 pyyaml-6.0 rich-12.2.0 scipy-1.8.0 screeninfo-0.8 six-1.16.0 skia-pathops-0.7.2 stack-data-0.2.0 svgelements-1.6.12 sympy-1.10.1 tqdm-4.64.0 traitlets-5.1.1 validators-0.18.2 wcwidth-0.2.5\n&lt;!-- 检查 --&gt;\nmanimgl\n&lt;!-- 提示 ffmpeg 未安装 --&gt;\nD:\\Python3.10.0\\lib\\site-packages\\pydub\\utils.py:170: RuntimeWarning: Couldn&#39;t find ffmpeg or avconv - defaulting to ffmpeg, but may not work\n  warn(&quot;Couldn&#39;t find ffmpeg or avconv - defaulting to ffmpeg, but may not work&quot;, RuntimeWarning)\n&lt;!-- ffmpeg windows 下载地址: https:&#x2F;&#x2F;archive.org&#x2F;download&#x2F;zeranoe&#x2F;win64&#x2F; --&gt;\n&lt;!-- 选择 static&#x2F; 及相应的版本 --&gt;\n\n\nffmpeg 安装&lt;!-- 搜索 -&gt; 编辑系统环境变量 -&gt; 环境变量 -&gt; 用户变量 -&gt; Path --&gt;\n&lt;!-- 在 Path 中添加 ffmpeg bin 文件夹的目录 --&gt;\n&lt;!-- 以下为示例 --&gt;\nD:\\FirefoxDownload\\ffmpeg-latest-win64-static\\ffmpeg-latest-win64-static\\bin\n&lt;!-- 配置完成后检查 ffmpeg 和 manimgl --&gt;\nffmpeg -version\n&lt;!-- 提示 ffmpeg 版本信息 --&gt;\nffmpeg version git-2020-08-31-4a11a6f Copyright (c) 2000-2020 the FFmpeg developers\nbuilt with gcc 10.2.1 (GCC) 20200805\n&lt;!-- manimgl -version --&gt;\nmanimgl -version\n&lt;!-- 提示 manimgl 版本信息 --&gt;\nManimGL v1.6.0\n&lt;!-- 至此, 已成功完成 ffmpeg 和 manimgl 的安装 --&gt;\n&lt;!-- Have fun! --&gt;\n\n\nmanim 的使用3b1b Manim GitHub\nManim Documentation\nManim 中文使用文档\nffmpeg 的使用ffmpeg\nffmpeg Documentation\nffmpeg GitHub\nffmpeg Wikipedia\nffmpeg 中文维基百科\n\n","slug":"pip安装第三方库报错","date":"2022-04-09T16:51:26.000Z","categories_index":"","tags_index":"mainm,pip,python","author_index":"paranoia"},{"id":"afa662091cf53ca79a8858de12df085e","title":"LeetCode-796-Rotate-String","content":"\n题目描述LeetCode-796-Rotate-String\nGiven two strings s and goal, return true if and only if s can become goal after some number of shifts on s.A shift on s consists of moving the leftmost character of s to the rightmost position.\n\nFor example, if s &#x3D; &quot;abcde&quot;, then it will be &quot;bcdea&quot; after one shift.\n\nExample1:\nInput: s &#x3D; &quot;abcde&quot;, goal &#x3D; &quot;cdeab&quot;\nOutput: true\nExample2:\nInput: s &#x3D; &quot;abcde&quot;, goal &#x3D; &quot;abced&quot;\nOutput: false\n\nContains:\n\n1 &lt;&#x3D; s.length, goal.length &lt;&#x3D; 100\ns and goal consist of lowercase English letters.\n\n\n算法思路本题中, 对字符串每进行一次 shift 操作, 就相当于把字符串最左边字符 (首字符) 和最右边字符 (尾字符) 交换位置。\n对于字符串 abcde, 我们重复进行 shift 操作后可以发现: 在第 5 (即 s.length + 1) 次操作后便回到了原来的 s, 这表明可以通过 s.length + 1 次 shift 操作得到 s。\nabcde –&gt; bcdea –&gt; cdeab –&gt; deabc –&gt; eabcd –&gt; abcde\n\n算法一 (最朴素的算法)function rotateString(s, goal) &#123;\n    let sLength &#x3D; s.length;\n    &#x2F;&#x2F; 深复制字符串 s\n    let temp &#x3D; s.slice();\n    for (let i &#x3D; 0; i &lt; sLength; i++) &#123;\n        if (temp &#x3D;&#x3D;&#x3D; goal) &#123;\n            return true;\n        &#125;\n        else &#123;\n            &#x2F;&#x2F; 更新 temp\n            temp &#x3D; temp.slice(1, sLength) + temp[0];\n        &#125;\n    &#125;\n    return false;\n&#125;\nconsole.log(rotateString(&quot;abcde&quot;, &quot;cdeab&quot;)); &#x2F;&#x2F; true\nconsole.log(rotateString(&quot;abcde&quot;, &quot;abced&quot;)); &#x2F;&#x2F; false\nconsole.log(rotateString(&quot;a&quot;, &quot;aa&quot;)); &#x2F;&#x2F; false\nconsole.log(rotateString(&quot;aa&quot;, &quot;a&quot;)); &#x2F;&#x2F; false\n\n若使 Output 为 [true, index] 或 [false, -1], 其中 index 表示对字符串 s 进行  shift 操作首次得到 goal 所需的操作次数, -1 表示无法通过 shift 操作得到 goal, 则算法一可改写如下:\nfunction rotateString(s, goal) &#123;\n    let sLength &#x3D; s.length;\n    &#x2F;&#x2F; 深复制字符串 s\n    let temp &#x3D; s.slice();\n    for (let i &#x3D; 0; i &lt; sLength; i++) &#123;\n        if (temp &#x3D;&#x3D;&#x3D; goal) &#123;\n            return [true, i];\n        &#125;\n        else &#123;\n            &#x2F;&#x2F; 更新 temp\n            temp &#x3D; temp.slice(1, sLength) + temp[0];\n        &#125;\n    &#125;\n    return [false, -1];\n&#125;\nconsole.log(rotateString(&quot;abcde&quot;, &quot;cdeab&quot;)); &#x2F;&#x2F; [true, 2]\nconsole.log(rotateString(&quot;abcde&quot;, &quot;abced&quot;)); &#x2F;&#x2F; [false, -1]\nconsole.log(rotateString(&quot;a&quot;, &quot;aa&quot;)); &#x2F;&#x2F; [false, -1]\nconsole.log(rotateString(&quot;aa&quot;, &quot;a&quot;)); &#x2F;&#x2F; [false, -1]\n\n\n算法二 (利用小技巧)依次将每次操作时的首字符添加到原字符串 s 的尾部, 便可得到新字符串: abcdeabcde, 这正好就是将原字符串 s 重复一次。 因此只要将字符串 s 和字符串 s 拼接在一起, 就可以在新的字符串里搜索字符串 goal。\nfunction rotateString(s, goal) &#123;\n    &#x2F;&#x2F; 若两个字符串长度不等,直接返回 false\n    &#x2F;&#x2F; 在两个字符串长度相等的前提下, 先复制字符串 s 两次, 再在此字符串中查找 goal\n    return (s.length &#x3D;&#x3D;&#x3D; goal.length) ? s.repeat(2).includes(goal) : false;\n&#125;\nconsole.log(rotateString(&quot;abcde&quot;, &quot;cdeab&quot;)); &#x2F;&#x2F; true\nconsole.log(rotateString(&quot;abcde&quot;, &quot;abced&quot;)); &#x2F;&#x2F; false\nconsole.log(rotateString(&quot;a&quot;, &quot;aa&quot;)); &#x2F;&#x2F; false\nconsole.log(rotateString(&quot;aa&quot;, &quot;a&quot;)); &#x2F;&#x2F; false\n\n其中, includes() 方法是区分大小写的, 例如:\n&#39;Blue Whale&#39;.includes(&#39;blue&#39;); &#x2F;&#x2F; false\n&#39;Blue Whale&#39;.includes(&#39;Blue&#39;); &#x2F;&#x2F; true\n\n若使 Output 为 [true, index] 或 [false, -1], 其中 index 表示对字符串 s 进行  shift 操作首次得到 goal 所需的操作次数, -1 表示无法通过 shift 操作得到 goal, 则算法二可改写如下:\nfunction rotateString(s, goal) &#123;\n    &#x2F;&#x2F; 当两字符串长度相等且查找结果不为 -1 时, 返回 [true, index]\n    &#x2F;&#x2F; 否则返回 [false, -1]\n    return ((s.length &#x3D;&#x3D;&#x3D; goal.length) &amp;&amp; (s.repeat(2).indexOf(goal) !&#x3D;&#x3D; -1)) ? [true, s.repeat(2).indexOf(goal)] : [false, -1];\n&#125;\nconsole.log(rotateString(&quot;abcde&quot;, &quot;cdeab&quot;)); &#x2F;&#x2F; [true, 2]\nconsole.log(rotateString(&quot;abcde&quot;, &quot;abced&quot;)); &#x2F;&#x2F; [false, -1]\nconsole.log(rotateString(&quot;a&quot;, &quot;aa&quot;)); &#x2F;&#x2F; [false, -1]\nconsole.log(rotateString(&quot;aa&quot;, &quot;a&quot;)); &#x2F;&#x2F; [false, -1]\n\n其中, 字符串的 indexOf() 方法的返回值如下图所示:\n\n\n统计一个字符串中某个字符或字符串出现的次数function repeatCounts(stringOne, stringTwo) &#123;\n    let count &#x3D; 0;\n    let index &#x3D; stringOne.indexOf(stringTwo);\n    &#x2F;&#x2F; 如果在 stringOne 中找到了 stringTwo, 即: index 不为 -1\n    while (index !&#x3D;&#x3D; -1) &#123;\n        count++;\n        &#x2F;&#x2F; 更新 index (从 index + 1 处开始查找)\n        index &#x3D; stringOne.indexOf(stringTwo, index + 1);\n    &#125;\n    return count;\n&#125;\nconsole.log(repeatCounts(&quot;abcde&quot;, &quot;f&quot;)); &#x2F;&#x2F; 0\nconsole.log(repeatCounts(&quot;f&quot;, &quot;abcde&quot;)); &#x2F;&#x2F; 0\nconsole.log(repeatCounts(&quot;abcde&quot;, &quot;c&quot;)); &#x2F;&#x2F; 1\nconsole.log(repeatCounts(&quot;abcce&quot;, &quot;c&quot;)); &#x2F;&#x2F; 2\nconsole.log(repeatCounts(&quot;abccc&quot;, &quot;c&quot;)); &#x2F;&#x2F; 3\n\n\n","slug":"LeetCode-796-Rotate-String","date":"2022-04-07T14:48:10.000Z","categories_index":"","tags_index":"LeetCode","author_index":"paranoia"},{"id":"327a088abef05846131669526f1edcfc","title":"JavaScript类型校验函数封装","content":"类型校验函数的封装&#x2F;&#x2F; JavaScript 类型校验 checkType 函数, 返回值为字符串类型\nfunction typeCheck(value) &#123;\n    &#x2F;&#x2F; 1. null\n    &#x2F;&#x2F; typeof() 方法对 null (空对象指针) 会返回字符串 &quot;object&quot;, 因此需对 null 特殊处理\n    if (value &#x3D;&#x3D;&#x3D; null) return &quot;null&quot;;\n\n    &#x2F;&#x2F; 2. NaN\n    &#x2F;&#x2F; 对值为 NaN 的数字, 返回 &quot;number NaN&quot;\n    &#x2F;&#x2F; 利用 Number.isNaN() 方法判断 NaN, 或者利用 NaN 永不等于自身这一特性判断 NaN\n    if (Number.isNaN(value)) return &quot;number NaN&quot;;\n    &#x2F;&#x2F; if (value !&#x3D;&#x3D; value) return &quot;number NaN&quot;;\n\n    &#x2F;&#x2F; 3. +Infinity 与 -Infinity\n    &#x2F;&#x2F; 对值为 Infinity 的数字, 返回 &quot;number Infinity&quot;\n    &#x2F;&#x2F; (value &#x3D;&#x3D;&#x3D; Infinity) ? (&quot;number +Infinity&quot;) : (value &#x3D;&#x3D;&#x3D; -Infinity) ? &quot;number -Infinity&quot; : &quot;&quot;;\n    if (value &#x3D;&#x3D;&#x3D; Infinity) return &quot;number +Infinity&quot;;\n    if (value &#x3D;&#x3D;&#x3D; -Infinity) return &quot;number -Infinity&quot;;\n\n    &#x2F;&#x2F; 4. 除掉上述特殊类型 (null, NaN, +Infinity, -Infinity, BigInt) 的原始类型\n    &#x2F;&#x2F; 利用 typeof() 方法对原始类型进行类型校验\n    if (typeof (value) !&#x3D;&#x3D; &quot;object&quot;) &#123;\n        return typeof (value);\n    &#125;\n\n    &#x2F;&#x2F; 5. 对于对象, Object.prototype.toString.call() 方法返回一字符串\n    &#x2F;&#x2F; 该字符串的前七个字符为固定的 &quot;object &quot;(注意最后一个空格分隔符)\n    &#x2F;&#x2F; 第八个字符为大写, 须转换为小写, 从而对于对象返回其类型 (全小写的字符串)\n    else return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();\n&#125;\n&#x2F;&#x2F; typeCheck 函数返回值为字符串\nconsole.log(typeCheck(1) &#x3D;&#x3D;&#x3D; &quot;number&quot;); &#x2F;&#x2F; true\nconsole.log(typeCheck(1)); &#x2F;&#x2F; number\nconsole.log(typeCheck(&quot;1&quot;)); &#x2F;&#x2F; string\nconsole.log(typeCheck(&quot;&quot;)); &#x2F;&#x2F; string\nconsole.log(typeCheck(true)); &#x2F;&#x2F; boolean\nconsole.log(typeCheck(null));&#x2F;&#x2F; null\nconsole.log(typeCheck(undefined)); &#x2F;&#x2F; undefined\nconsole.log(typeCheck(NaN)); &#x2F;&#x2F; number NaN\nconsole.log(typeCheck(Infinity)); &#x2F;&#x2F; number +Infinity\nconsole.log(typeCheck(-Infinity)); &#x2F;&#x2F; number -Infinity\n&#x2F;&#x2F; 整数字面量 + n 或调用函数 BigInt() 创建大整数 BigInt\nconsole.log(typeCheck(1n)); &#x2F;&#x2F; bigint\nconsole.log(typeCheck(BigInt(1))); &#x2F;&#x2F; bigint\n&#x2F;&#x2F; 对于Object 包装的 BigInt, typeof() 方法返回 &quot;object&quot;, Object.prototype.toString.call() 方法返回 &quot;object BigInt&quot;\n&#x2F;&#x2F; typeCheck() 函数同样对于 Object 包装的 BigInt 返回 &quot;bigint&quot;\nconsole.log(typeof (Object(1n))); &#x2F;&#x2F; object\nconsole.log(Object(1n) instanceof Object);\nconsole.log(Object.prototype.toString.call(Object(1n))); &#x2F;&#x2F; &quot;object BigInt&quot;\nconsole.log(typeCheck(Object(1n))); &#x2F;&#x2F; bigint\nconsole.log(typeCheck(&#123;&#125;)); &#x2F;&#x2F; object\nconsole.log(typeCheck([])); &#x2F;&#x2F; array\nconsole.log(typeCheck(Boolean)); &#x2F;&#x2F; function\nconsole.log(typeCheck(Boolean())); &#x2F;&#x2F; boolean\nconsole.log(typeCheck(Boolean(1))); &#x2F;&#x2F; boolean\nconsole.log(typeCheck(new Boolean(1))); &#x2F;&#x2F; boolean\nconsole.log(typeCheck(Number)); &#x2F;&#x2F; function\nconsole.log(typeCheck(Number())); &#x2F;&#x2F; number\nconsole.log(typeCheck(Number(&quot;1&quot;))); &#x2F;&#x2F; number\nconsole.log(typeCheck(new Number(&quot;1&quot;))); &#x2F;&#x2F; number\nconsole.log(typeCheck(Symbol())); &#x2F;&#x2F; symbol\nconsole.log(typeof (Object(Symbol()))); &#x2F;&#x2F; object\nconsole.log(Object.prototype.toString.call(Object(Symbol()))); &#x2F;&#x2F; &quot;object Symbol&quot;\nconsole.log(typeCheck(Object(Symbol()))); &#x2F;&#x2F; symbol\nconsole.log(typeCheck(new Date())); &#x2F;&#x2F; date\nconsole.log(typeCheck(new RegExp())); &#x2F;&#x2F; regexp\nconsole.log(typeCheck(function () &#123; &#125;)); &#x2F;&#x2F; function\nconsole.log(typeCheck(new function () &#123; &#125;)); &#x2F;&#x2F; object\nconsole.log(typeCheck(function () &#123; return this; &#125;())); &#x2F;&#x2F; global (立即调用的未明确指定 this 值的函数表达式, 返回 global 全局对象)\nconsole.log(typeCheck(Math.sin)); &#x2F;&#x2F; function\nconsole.log(typeCheck(Math.sin())); &#x2F;&#x2F; number NaN\nconsole.log(typeCheck(Math.sin(1))); &#x2F;&#x2F; number\nconsole.log(typeCheck(class &#123;&#125;)); &#x2F;&#x2F; function\nconsole.log(typeCheck(class Person &#123;&#125;)); &#x2F;&#x2F; function\nconsole.log(typeCheck(new typeCheck())); &#x2F;&#x2F; object\nconsole.log(typeof(typeCheck(new typeCheck())) &#x3D;&#x3D;&#x3D; &quot;string&quot;); &#x2F;&#x2F; true\nconsole.log(Object.prototype.toString.call(new typeCheck())); &#x2F;&#x2F; &quot;object Object&quot;\nconsole.log(typeof(Object.prototype.toString.call(new typeCheck())) &#x3D;&#x3D;&#x3D; &quot;string&quot;); &#x2F;&#x2F; true\n","slug":"JavaScript类型校验函数封装","date":"2022-04-06T18:09:03.000Z","categories_index":"","tags_index":"JavaScript,类型校验,封装函数","author_index":"paranoia"},{"id":"0bbd469acde6df175f056490e56783a8","title":"排序算法之JavaScript实现","content":"","slug":"排序算法之JavaScript实现","date":"2022-03-30T08:29:25.000Z","categories_index":"","tags_index":"","author_index":"paranoia"},{"id":"120b4f6647606fb186b9a22d3e519b62","title":"由LeetCode第一题两数之和说起","content":"题目描述基本描述: 给定一个整数数组 nums 和一个整数目标值 target，找出 数组 nums 中和为目标值 target 的那两个整数，并返回这个两个整数对应的数组下标。假定每种输入只会对应一个输出 (要么无解, 要么仅有一解), 且数组 nums 中元素具有唯一性。\n基本解法一function twoNumberSum(array, targetSum) &#123;\n    let tempArray &#x3D; array.map(item &#x3D;&gt; (targetSum - item));\n    let result &#x3D; [];\n    for (i &#x3D; 0; i &lt; array.length; i++) &#123;\n        if (array.indexOf(tempArray[i]) !&#x3D; -1 &amp;&amp; array.indexOf(tempArray[i]) !&#x3D; i) &#123;\n            result.push(array.indexOf(tempArray[i]));\n        &#125;\n    &#125;\n    if (result.length &#x3D;&#x3D;&#x3D; 0) &#123;return &#96;数组 $&#123;JSON.stringify(array)&#125; 中找不到两数之和为 $&#123;targetSum&#125;&#96;;&#125;\n    else &#123;return result[0] &gt; result[1] ? [result[1], result[0]] : result;&#125;\n&#125;\nconsole.log(twoNumberSum([3, 5, -4, 8, 11, 1, -1, 6], 10)); &#x2F;&#x2F; [4, 6] (因 11 + -1 &#x3D; 10)\nconsole.log(twoNumberSum([3, 5, -4, 8, 11, 1, -1, 6], 100));\n&#x2F;&#x2F; 数组 [3, 5, -4, 8, 11, 1, -1, 6] 中找不到两数之和为 100\n\n注意:\n\n上述代码中须保证 array.indexOf(tempArray[i]) != i, 以防止 数组 array 中存在 targetSum 的一半, 如 [1, 3, 5, 7] 和 10, 其中 5 是 10的一半;\n当数组中找不到两数之和时, 若直接使用 $&#123;array&#125;, 则会调用数组的 toString() 方法将数组强制转型为字符串, 因而须改用 $&#123;JSON.stringify(array)&#125; 来输出数组;\nreturn result[0] &gt; result[1] ? [result[1], result[0]] : result; 是为了使结果以升序排列。\n\n将上述代码中的 array 和 targetSum 改为 nums 和 target:\nfunction twoNumberSum(nums, target) &#123;\n    let tempArray &#x3D; nums.map(item &#x3D;&gt; (target - item));\n    let result &#x3D; [];\n    for (i &#x3D; 0; i &lt; nums.length; i++) &#123;\n        if (nums.indexOf(tempArray[i]) !&#x3D; -1 &amp;&amp; nums.indexOf(tempArray[i]) !&#x3D; i) &#123;\n            result.push(nums.indexOf(tempArray[i]));\n        &#125;\n        else &#123;return &#96;数组 $&#123;JSON.stringify(nums)&#125; 中找不到两数之和为 $&#123;target&#125;&#96;;&#125;\n    &#125;\n    return result[0] &gt; result[1] ? [result[1], result[0]] : result;\n&#125;","slug":"由LeetCode第一题两数之和说起","date":"2022-03-28T17:36:49.000Z","categories_index":"","tags_index":"","author_index":"paranoia"},{"id":"01cf899dac80c5a14d5d881768abc55f","title":"树","content":"","slug":"树","date":"2022-03-28T16:54:52.000Z","categories_index":"","tags_index":"","author_index":"paranoia"},{"id":"7db2446ec2832237dd5967bf88c6a08e","title":"JavaScript数据类型及类型判断","content":"JavaScript类型基本类型JavaScript基本类型有 7 种: Undefined、Null、Boolean、Number、String、Symbol 和 BigInt, 其中Symbol为 ECMAScript 6 新增类型。\n引用类型JavaScript引用类型仅 Object 一种。 对象指内存中可以被标识符引用的一块区域, 在 JavaScript 中, 对象还可被视为一个无序键值对的集合 (散列表), 是某个特定引用类型的实例, 通常可使用 new 关键字后接构造函数 (constructor)创建:\nlet dateObject &#x3D; new Date(); &#x2F;&#x2F; 日期对象\nlet regExpObject &#x3D; new RegExp([0-9]); &#x2F;&#x2F; 正则表达式对象\nlet object &#x3D; new Object(); &#x2F;&#x2F; 自定义对象\nlet functionObject &#x3D; new Function(); &#x2F;&#x2F; 函数对象\nlet symbolObject &#x3D; new Symbol(); &#x2F;&#x2F; 符号对象\nlet booleanObject &#x3D; new Boolean(); &#x2F;&#x2F; Boolean 对象\nlet numberObject &#x3D; new Number(); &#x2F;&#x2F; Number 对象\nlet stringObject &#x3D; new String(); &#x2F;&#x2F; String 对象\nlet arrayObject &#x3D; new Array(); &#x2F;&#x2F; Array 对象\nlet mapObject &#x3D; new Map(); &#x2F;&#x2F; Map 对象\nlet weakMapObject &#x3D; new WeakMap(); &#x2F;&#x2F; WeakMap 对象\nlet setObject &#x3D; new Set(); &#x2F;&#x2F; Set 对象\nlet weakSetObject &#x3D; new WeakSet(); &#x2F;&#x2F; WeakSet 对象\nlet errorObject &#x3D; new Error(); &#x2F;&#x2F; Error 对象\nlet typedArrayObject &#x3D; new Int8Array(2); &#x2F;&#x2F; 长度为 2 的 Int8Array 定型数组对象\n\n其中:\n\nBoolean、Number 和 String 对象为 JavaScript 的三大原始值包装类型, 每个原始值包装类型均映射到对应的同名原始类型, 如 Boolean 是对应数值的引用类型。\nMap、WeakMap、Set 和 WeakSet 对象为 JavaScript 键控集 (keyed collections), 这些数据结构把对象的引用作为键。\n\nBigInt 对象BigInt 对象可通过 BigInt 函数生成 BigInt 类型的整数, 用以精确表示任意位数的整数。\n\nBigInt 函数不能连同 new 关键字使用:let bigIntObject &#x3D; new BigInt(1); &#x2F;&#x2F; TypeError: BigInt is not a constructor\nBigInt 函数必须有参数, 且若参数不是 Number 类型, 将会自动调用 Number() 转换规则将其转换为 BigInt。无法解析成 Number 类型的参数 (如字符串) 或参数为小数, 均会报错。\n\nBigInt(); &#x2F;&#x2F; TypeError: Cannot convert undefined to a BigInt\nBigInt(undefined); &#x2F;&#x2F; TypeError: Cannot convert undefined to a BigInt\nBigInt(null); &#x2F;&#x2F; TypeError: Cannot convert null to a BigInt\nBigInt(&quot;1a&quot;); &#x2F;&#x2F; SyntaxError: Cannot convert 1a to a BigInt\nBigInt(1.5); &#x2F;&#x2F; RangeError: The number 1.5 cannot be converted to a BigInt because it is not an integer\nBigInt(1); &#x2F;&#x2F; 1n\nBigInt(true); &#x2F;&#x2F; 1n\nBigInt(false); &#x2F;&#x2F; 0n\n\nBigInt 不可与 Number 混合操作, 若需要，则需使用 BigInt() 或 Number() 显示转换为同一类型后再执行相应操作。1n + 1; &#x2F;&#x2F; TypeError: Cannot mix BigInt and other types, use explicit conversions\n1n + BigInt(1); &#x2F;&#x2F; 2n\nNumber(1n) + 1; &#x2F;&#x2F; 2\nMath.sqrt(4n); &#x2F;&#x2F; TypeError: Cannot convert a BigInt to a number\nBigInt 类型判断。Object.prototype.toString.call(BigInt(1)); &#x2F;&#x2F; &quot;[object BigInt]&quot;\nObject.prototype.toString.call(1n); &#x2F;&#x2F; &quot;[object BigInt]&quot;\nObject.prototype.toString.call(BigInt); &#x2F;&#x2F; &quot;[object Function]&quot;\ntypeof 1n; &#x2F;&#x2F; &quot;bigint&quot;\ntypeof BigInt(1); &#x2F;&#x2F; &quot;bigint&quot;\ntypeof Object(1n); &#x2F;&#x2F; &quot;object&quot;\ntypeof 1n &#x3D;&#x3D;&#x3D; typeof BigInt(1); &#x2F;&#x2F; true\ntypeof 1n &#x3D;&#x3D;&#x3D; typeof Object(1n); &#x2F;&#x2F; false\n\nGlobal 对象和 Math 对象JavaScript 内置对象指任何由 ECMAScript 6 实现提供且与宿主环境无关, 在 ECMAScript 程序开始执行时便已存在的对象, 有 Global 和 Math 两个内置对象。\nGlobal 对象是 JavaScript 中最为特别的对象: 在大多数 ECMAScript 实现中无法直接访问, 为兜底对象, 浏览器将 Global 对象实现为 window 对象。在全局作用域中定义的变量和函数都会变成 Global 对象的属性。\nMath 对象为数学常数和函数提供了静态属性和静态方法, 它没有其他 JavaScript 对象类似的构造函数 Math(), 无须实例化, 所有属性和方法可直接在 Math 对象上调用。Math 对象不是函数对象:\nObject.prototype.toString.call(Math); &#x2F;&#x2F; &quot;[object Math]&quot;\nObject.prototype.toString.call(Math.sin); &#x2F;&#x2F; &quot;[object Function]&quot;\nObject.prototype.toString.call(Math.sin()); &#x2F;&#x2F; &quot;[object Number]&quot;\n\n基本类型与引用类型的异同基本类型也称原始类型、简单数据类型。为提升变量查询速度, 基本类型存储于栈 (stack)中, 按值 (by value) 访问。\n引用类型也称复杂数据类型, 是保存在内存中的对象。由于 JavaScript 不允许直接访问内存位置, 因而也不能直接操作对象所在的内存空间, 实际操作对象的是该对象的引用而非对象本身, 也即按引用 (by reference) 访问。引用类型可理解为一个指向存储对象的内存处的指针。\n类型判断由于 ECMAScript 类型系统是松散的, 因此需要一些手段检测任意给定变量的数据类型。\ntypeof 操作符typeof 操作符最适合用于判断一个变量是否为原始类型, 语法为:\ntypeof operand\ntypeof(operand)\n\n其中, operand 表示一个表示原始值或对象的一元表达式, typeof 操作符将返回相应的类型:\n\n对于除 null 外的基本类型, 均返回正确的结果;\n对于除 Function 外的引用类型, 均返回 &quot;object&quot;;\n对于 null 返回 &quot;object&quot;;\n对于 Function, 返回 &quot;function&quot;\n\n&#x2F;&#x2F; 原始值\ntypeof undefined; &#x2F;&#x2F; &quot;undefined&quot;\ntypeof null; &#x2F;&#x2F; &quot;object&quot;\ntypeof true; &#x2F;&#x2F; &quot;boolean&quot;\ntypeof false; &#x2F;&#x2F; &quot;boolean&quot;\ntypeof Boolean(1); &#x2F;&#x2F; &quot;boolean&quot;\ntypeof 1; &#x2F;&#x2F; &quot;number&quot;\ntypeof &quot;a&quot;; &#x2F;&#x2F; &quot;string&quot;\ntypeof Symbol(); &#x2F;&#x2F; &quot;symbol&quot;\ntypeof 1n; &#x2F;&#x2F; &quot;bigint&quot;\n\ntypeof 操作符对 null 特殊值返回了 &quot;object&quot;, 这是因为从逻辑上讲, null 特殊值表示一个空对象指针 (大多数平台下其值为 0x00), 更多详情请查阅: The history of “typeof null”\n&#x2F;&#x2F; 对象\ntypeof &#123;&#125;; &#x2F;&#x2F; &quot;object&quot;\ntypeof &#123;a: 1&#125;; &#x2F;&#x2F; &quot;object&quot;\ntypeof []; &#x2F;&#x2F; &quot;object&quot;\ntypeof [1, 2, 3]; &#x2F;&#x2F; &quot;object&quot;\ntypeof new Date(); &#x2F;&#x2F; &quot;object&quot;\ntypeof new RegExp([0-9]); &#x2F;&#x2F; &quot;object&quot;\ntypeof new Function(); &#x2F;&#x2F; &quot;function&quot;\ntypeof Math.sin; &#x2F;&#x2F; &quot;function&quot;\ntypeof document.all; &#x2F;&#x2F; &quot;undefined&quot;\n对于一般对象而言, typeof 操作符均返回 &quot;object&quot;。除 Function 构造函数的类型为 &quot;function&quot;外, 其余所有构造函数的类型均为 &quot;object&quot;。当前所有浏览器都暴露了一个非标准宿主对象 document.all, typeof 操作符对其返回 &quot;undefined&quot;。\ntypeof 操作符对原始类型很有作用, 但对引用类型却束手无策: 它无法确定对象的确切类型 (对大多数对象均返回 &quot;object&quot; 同一结果)。为解决上述问题, ECMAScript 提供了 instanceof 操作符, 用以检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。\ninstanceof 操作符instanceof 操作符语法为:\nobject instanceof constructor\n\ninstanceof 操作符用于判断 object 是否为 constructor 的实例。根据定义, 所有引用类型都是 Object (均由 Object 类派生而来) 的实例, instanceof 操作符均返回 true。若用 instanceof 操作符检测原始值, 则始终返回 false。\nlet simpleString &#x3D; &quot;This is a simple string&quot;; &#x2F;&#x2F; 字符串\nlet stringLiteral &#x3D; &#96;This is a string literal&#96;; &#x2F;&#x2F; 模板字面量定义字符串\nlet newString &#x3D; new String(&quot;This is a new string&quot;); &#x2F;&#x2F; new + constructor\nlet newDate &#x3D; new Date(); &#x2F;&#x2F; new + constructor\nlet objectLiteral &#x3D; &#123;&#125;; &#x2F;&#x2F; 对象字面量\nlet newObject &#x3D; new Object(); &#x2F;&#x2F; new + constructor\nlet arrayLiteral &#x3D; []; &#x2F;&#x2F; 数组字面量\nlet newArray &#x3D; new Array(); &#x2F;&#x2F; new + constructor\n\nsimpleString instanceof Object; &#x2F;&#x2F; false\nstringLiteral instanceof Object; &#x2F;&#x2F; false\nnewString instanceof Object; &#x2F;&#x2F; true\nnewDate instanceof Object; &#x2F;&#x2F; true\nobjectLiteral instanceof Object; &#x2F;&#x2F; true\nnewObject instanceof Object; &#x2F;&#x2F; true\narrayLiteral instanceof Object; &#x2F;&#x2F; true\nnewArray instanceof Object; &#x2F;&#x2F; true\n\nsimpleString instanceof String; &#x2F;&#x2F; false\nstringLiteral instanceof String; &#x2F;&#x2F; false\nnewString instanceof String; &#x2F;&#x2F; true\nnewDate instanceof Date; &#x2F;&#x2F; true\nobjectLiteral instanceof Object; &#x2F;&#x2F; true\nnewObject instanceof Object; &#x2F;&#x2F; true\narrayLiteral instanceof Array; &#x2F;&#x2F; true\nnewArray instanceof Array; &#x2F;&#x2F; true\n\n1 instanceof Object; &#x2F;&#x2F; false\n\n使用单引号 (‘’) 、双引号 (“”) 和模板字面量(&#96;&#96;) 定义的字符串非对象实例,因而 instanceof 操作符对其均返回 false。使用对象字面量 ({}) 定义的对象, 尽管原型无定义, 但 instanceof 操作符 对其返回 true。\n要检测对象不是某个构造函数的实例时, 可以这样操作:\n&#x2F;&#x2F; 逻辑非 ! 其后的表达式须用 () 包裹, 否则 JavaScript 先执行 !obj, if 的条件表达式求职结果将始终为 false\nif (!(obj instanceof constructor)) &#123;\n    &#x2F;&#x2F; Do something like obj &#x3D; new constructor()\n&#125;\n\nObject.prototype.toString.call()toString()是 Object 原型对象上的一个方法, 默认返回其调用者的具体类型—— toString 运行时 this 指向的对象类型, 返回 &quot;[object xxx]&quot;, 其中 xxx 表示具体的数据类型, 如 Sting、Number、Boolean、Undefined、Null、Date、RegExp、Function、Error、Array、Object、HTMLDocument 和 Window 等。\nObject.prototype.toString.call(&quot;&quot;); &#x2F;&#x2F; &quot;[object String]&quot;\nObject.prototype.toString.call(1); &#x2F;&#x2F; &quot;[object Number]&quot;\nObject.prototype.toString.call(true); &#x2F;&#x2F; &quot;[object Boolean]&quot;\nObject.prototype.toString.call(undefined); &#x2F;&#x2F; &quot;[object undefined]&quot;\nObject.prototype.toString.call(null); &#x2F;&#x2F; &quot;[object Null]&quot;\nObject.prototype.toString.call(new Date()); &#x2F;&#x2F; &quot;[object Date]&quot;\nObject.prototype.toString.call(new RegExp()); &#x2F;&#x2F; &quot;[object RegExp]&quot;\nObject.prototype.toString.call(new Function()); &#x2F;&#x2F; &quot;[object Function]&quot;\nObject.prototype.toString.call(new Error()); &#x2F;&#x2F; &quot;[object Error]&quot;\nObject.prototype.toString.call([]); &#x2F;&#x2F; &quot;[object Array]&quot;\nObject.prototype.toString.call(&#123;&#125;); &#x2F;&#x2F; &quot;[object Object]&quot;\nObject.prototype.toString.call(document); &#x2F;&#x2F;  &quot;[object HTMLDocument]&quot;\nObject.prototype.toString.call(window); &#x2F;&#x2F; &quot;[object Window]&quot;\n\nObject.prototype.toString.call() 方法对 null 和 undefined 直接返回对应的 &quot;[object Null]&quot; 和 &quot;[object Undefined]&quot; 。因为大部分内置对象都会重写 toString 方法, 所以须使用 call 方法强制执行 Object 默认的 toString 方法。\nWarning: Object.prototype.toString.call() 方法 本身是允许被修改的, 因而上述代码中均基于 Object.prototype.toString.call() 方法未被修改的前提。\nconstructor 属性constructor 属性可检测某个实例对象是由哪个构造函数产生的:\nlet a &#x3D; 1;\na.constructor; &#x2F;&#x2F; [Function: Number]\n[].constructor; &#x2F;&#x2F; [Function: Array]\n&#123;&#125;.constructor; &#x2F;&#x2F; [Function: Object]\nnew Date().constructor; &#x2F;&#x2F; [Function: Date]\nnew RegExp().constructor; &#x2F;&#x2F; [Function: RegExp]\nnew Function().constructor; &#x2F;&#x2F; [Function: Function]\nnew Error().constructor; &#x2F;&#x2F; [Function: Error]\ntrue.constructor; &#x2F;&#x2F; [Function: Boolean]\ndocument.constructor; &#x2F;&#x2F; [Function: HTMLDocument]\nwindow.constructor; &#x2F;&#x2F; [Function: Window]\n\n\n\nundefined 和 null 无 constructor 属性。\nconstructor 属性的不稳定性: 在自定义对象时,容易重写 prototype, 原有的 constructor 引用会丢失, 变为 Object。function F() &#123;&#125;\nF.prototype &#x3D; &#123;&#125;\nlet f &#x3D; new F();\nf.constructor &#x3D;&#x3D;&#x3D; F; &#x2F;&#x2F; false\nf.constructor; &#x2F;&#x2F; [Function: Object]\n\nfunction F() &#123;&#125;\nlet f &#x3D; new F();\nf.constructor &#x3D;&#x3D;&#x3D; F; &#x2F;&#x2F; true\nf.constructor; &#x2F;&#x2F; [Function: F]\nJavaScript 第三方库lodash.jsunderscore.jsNode.js 的 util 模块Node.js 官网: util 模块\nlet util &#x3D; require(&quot;util&quot;);\nlet a &#x3D; [];\nconsole.log(util.isArray(a)); &#x2F;&#x2F; true\njQuery使用 jQuery 提供的 type() 方法:\nconst &#123; JSDOM &#125; &#x3D; require( &quot;jsdom&quot; );\nconst &#123; window &#125; &#x3D; new JSDOM( &quot;&quot; );\nconst $ &#x3D; require( &quot;jquery&quot; )( window );\n\nconsole.log($.type([])); &#x2F;&#x2F; array\nconsole.log($.type([]) &#x3D;&#x3D;&#x3D; &quot;array&quot;); &#x2F;&#x2F; true\n\n&#x2F;&#x2F; or like this\nconst &#123; JSDOM &#125; &#x3D; require( &quot;jsdom&quot; );\nconst &#123; window &#125; &#x3D; new JSDOM( &quot;&quot; );\nconst $ &#x3D; require( &quot;jquery&quot; )( window );\n\nconsole.log($.type([])); &#x2F;&#x2F; array\nconsole.log($.type([]) &#x3D;&#x3D;&#x3D; &quot;array&quot;); &#x2F;&#x2F; true\n\nRead also:\n\nJQuery | type() method\njQuery source code\nYou might not need jQuery\n《 jQuery Fundamentals 》 by Rebecca Murphey\n\n","slug":"JavaScript数据类型及类型判断","date":"2022-03-25T14:04:13.000Z","categories_index":"","tags_index":"JavaScript,基本类型,引用类型,类型判断","author_index":"paranoia"},{"id":"654476d034e547d801722bf0f52fe54c","title":"JavaScript隐式类型转换","content":"JavaScript 何时会发生隐式类型转换JavaScript 是弱类型语言, 当其期望得到某种数据类型而不得时, 会强制发生隐式类型转换。\n自加操作符 (++) 和自减操作符 (--)自加操作符和自减操作符均有前缀 (prefix) 和后缀 (postfix) 之分:\n++i; &#x2F;&#x2F; 前缀自加操作符\ni++; &#x2F;&#x2F; 后缀自加操作符\n--i; &#x2F;&#x2F; 前缀自减操作符\ni--; &#x2F;&#x2F; 后缀自减操作符\n\n对于前缀版自加或自减操作符, 变量的值在求值之前即被改变 (副作用); 而对于后缀版自加或自减操作符, 变量的值在求值之后才被改变 (滞后)。\nlet i &#x3D; 0;\nconsole.log(++i); &#x2F;&#x2F; 1\n\nlet j &#x3D; 0;\nconsole.log(j++); &#x2F;&#x2F; 0\nconsole.log(j); &#x2F;&#x2F; 1\n\n这四个一元操作符均会将非数值类型的操作数转换为数值:\n\n对于可以转换为数值的字符串, 如字符串 &quot;1&quot;, 则直接转换为数值再执行相应的操作;\n对于无法转换为数值的字符串, 如字符串 &quot;1a&quot;、&quot;a&quot;, 则将变量转换为 NaN(Not a Number) 再执行相应的操作;\n对于布尔值, true 和 false 分别转换为数值 1 和 0 再执行相应的操作;\n对于对象, 则调用其 valueOf() 方法, 若无 valueOf() 方法, 则继续调用其 toString() 方法, 最后将得到的字符串转换为数值后再执行相应的操作。\n\nlet stringOne &#x3D; &quot;1&quot;;\nconsole.log(++stringOne); &#x2F;&#x2F; 2\nlet stringTwo &#x3D; &quot;1a&quot;;\nconsole.log(++stringTwo); &#x2F;&#x2F; NaN\nlet booleanOne &#x3D; true;\nconsole.log(++booleanOne); &#x2F;&#x2F; 2\nlet booleanTwo &#x3D; false;\nconsole.log(++booleanTwo); &#x2F;&#x2F; 1\nlet objectOne &#x3D; &#123;a: 1&#125;;\nconsole.log(++objectOne); &#x2F;&#x2F; NaN\n\nlet objectTwo &#x3D; &#123;\n    valueOf() &#123;\n        return -1;\n    &#125; &#x2F;&#x2F; valueOf() 方法, 返回数值 -1\n&#125;;\nconsole.log(++objectTwo); &#x2F;&#x2F; 0\n\n一元加 (+)、一元减 (-) 和乘性操作符 (*、/、%)一元加 (+) 、一元减 (-) 、乘 (*) 、除 (/) 和 取模 (%) 操作符, 会调用 Number() 转型函数将非 Number 类型转换为 Number 类型。\n+ true; &#x2F;&#x2F; 1\n+ false; &#x2F;&#x2F; 0\n+ undefined; &#x2F;&#x2F; NaN\n+ null; &#x2F;&#x2F; Number() 转型函数对 null 返回 0\n+ NaN; &#x2F;&#x2F; NaN\n+ &quot;&quot;; &#x2F;&#x2F; 0\n\n加性操作符加性 (二元) 操作符分加法操作符 (+) 和减法操作符 (-), 分别用于求和和求差。\n减法操作符对非数值类型的操作数会按以下规则执行:\n\n如果操作数也不是对象, 则调用 Number() 转型函数将操作数转换为数值类型后再执行相应的操作;\n如果操作数是对象, 则调用其 valueOf() 方法, 若无 valueOf() 方法, 则继续调用其 toString() 方法, 最后将得到的字符串转换为数值后再执行相应的操作。\n\n1 - &quot;a&quot;; &#x2F;&#x2F; NaN\n\nlet objectOne &#x3D; &#123;\n    valueOf() &#123;\n        return -1;\n    &#125; &#x2F;&#x2F; valueOf() 方法, 返回数值 -1\n&#125;;\n1 + objectOne; &#x2F;&#x2F; 0\n\n加法操作符则与减法操作符有很大不同, 其原因为加法操作符还可以对字符串进行拼接, 因此加法操作符将按以下规则执行:\n\n两个操作数均为字符串, 则第二个字符串拼接至第一个字符串之后;\n有一个操作数是字符串, 则对另一个操作数调用 toString() 方法转换为字符串后进行拼接。\n\n&quot;a&quot; + &quot;b&quot;; &#x2F;&#x2F; &quot;ab&quot;\n1 + &quot;a&quot;; &#x2F;&#x2F; &quot;1a&quot;\n1 + &quot;&quot;; &quot;1&quot;\n\nlet objectOne &#x3D; &#123;\n    valueOf() &#123;\n        return &quot;a&quot;;\n    &#125; &#x2F;&#x2F; 重写 valueOf() 方法, 返回字符串 &quot;a&quot;\n&#125;;\nobjectOne + &quot;b&quot;; &#x2F;&#x2F; &quot;ab&quot;\n\n语句 (流控制语句)在 JavaScript 语句的条件表达式中期望得到一个布尔值, 如果不是布尔值, 则会调用 Boolean() 转型函数将其转换为布尔值。\n&#x2F;&#x2F; JavaScript 六大假值 (falsey): false, undefined, null, &quot;&quot;, 0(+0, -0), NaN\n&#x2F;&#x2F; 除六大假值之外的所有数据类型均为真值 (truthy)\n\n&#x2F;&#x2F; if 语句, 循环体均执行一次 (先测试循环)\nif (!false)\n    console.log(&quot;This is !false.&quot;);\nif (!undefined)\n    console.log(&quot;This is !undefined.&quot;);\nif (!null)\n    console.log(&quot;This is !null.&quot;);\nif (!NaN)\n    console.log(&quot;This is !NaN.&quot;);\nif (!&quot;&quot;)\n    &#x2F;&#x2F; &quot; 须使用 \\ 转义打印输出\n    console.log(&quot;This is !\\&quot;\\&quot;.&quot;);\nif (!0)\n    console.log(&quot;This is !0.&quot;);\nif (!NaN)\n    console.log(&quot;This is !NaN.&quot;);\n\n&#x2F;&#x2F; do-while 语句 (后测试循环)\n&#x2F;&#x2F; 循环体仅执行一次\ndo &#123;\n    console.log(&quot;This is false.&quot;);\n&#125; while (false); &#x2F;&#x2F; This is false.\n&#x2F;&#x2F; 若无 break 语句, 循环体将无限执行; break 语句可强制提前跳出循环\ndo &#123;\n    console.log(&quot;This is !false.&quot;);\n    break;\n&#125; while (!false); &#x2F;&#x2F; This is !false.\n\n&#x2F;&#x2F; while 语句 (先测试循环)\n&#x2F;&#x2F; 循环体永不执行\nwhile (false) &#123;\n    console.log(&quot;This is false.&quot;);\n&#125;\n&#x2F;&#x2F; 若无 break 语句, 循环体将无限执行; break 语句可强制提前跳出循环\nwhile (!false) &#123;\n    console.log(&quot;This is !false.&quot;);\n    break;\n&#125; &#x2F;&#x2F; This is !false.\n\n&#x2F;&#x2F; for 语句 (先测试循环)\n&#x2F;&#x2F; 循环体永不执行\nfor (; false;) &#123;\n    console.log(&quot;This is false.&quot;);\n&#125;\n&#x2F;&#x2F; 若无 break 语句, 循环体将无限执行; break 语句可强制提前跳出循环\nfor (; !false;) &#123;\n    console.log(&quot;This is !false.&quot;);\n    break;\n&#125; &#x2F;&#x2F; This is !false.\n\n&#x2F;&#x2F; switch语句\nswitch (false) &#123;\n    case true: console.log(&quot;This is true.&quot;);\n    case false: console.log(&quot;This is false.&quot;);\n&#125; &#x2F;&#x2F; This is false.\nswitch (!false) &#123;\n    case true: console.log(&quot;This is true.&quot;);\n        break;\n    case false: console.log(&quot;This is false.&quot;);\n        break;\n&#125; &#x2F;&#x2F; This is true.\n\n非数值转换为数值JavaScript 中有三个函数可以将非数值转换为数值: Number() 转型函数、parseInt() 和 parseFloat() 函数。\nNumber() 转型函数\n\n一元加操作符遵循 Number() 转型函数同样的非数值到数值的转换规则。\nparseInt() 函数parseInt() 函数\n非字符串转换为字符串\n\n非布尔值转换为布尔值\n\n","slug":"JavaScript隐式类型转换","date":"2022-03-25T14:02:59.000Z","categories_index":"","tags_index":"JavaScript,隐式类型转换","author_index":"paranoia"},{"id":"99327f04c23749b756244dec62781e9e","title":"命令行初探","content":"cd 命令 (change directory)cd 命令主要用于切换当前目录。\ncd 语法cd [&#x2F;d] [&lt;drive&gt;:][&lt;path&gt;]\ncd [..]\nchdir [&#x2F;d] [&lt;drive&gt;:][&lt;path&gt;]\nchdir [..]\n\ncd 帮助文件cd &#x2F;?\n\n返回至当前盘的根目录cd \\\n\n切换至 D 盘四种方式均可:\nD:\ncd &#x2F;d D:\ncd &#x2F;d D:&#x2F;\ncd &#x2F;d D:\\\n\n直接切换至某文件夹以下将分别切换至 D: \\work 和 D: \\work\\work\\work\ncd &#x2F;d D:\\work\ncd &#x2F;d D:\\work\\work\\work\n\n间接切换至某文件夹先切换到指定盘再切换到该盘的子文件夹, 以下将切换至 D: \\work\nD:\ncd work\n\n进入上一级目录 (父目录)若一直重复以下代码, 将进入当前盘的根目录, 等同于 cd \\\ncd ..\n\nRead also:\n\nMicrosoft CD\n\nMS-DOS 命令列表\n\n\n查询 ip 地址ipconfig\nipconfig&#x2F;all\n查询软件版本 (version)当使用一个 - 时, 大多数软件使用大写 V 即 -V, 少数软件使用小写 v 即 -v; 当使用两个 -- 时, 使用小写 v 开头的全称 version 即 --version。某些软件 (如 git) 可能仅支持 --version 的查询方法。\npython -V\npython --version\n\nnode -v\nnode --version\nnpm -v\nnpm --version\n\ngit --version\n\nnpm (node package manager)npm (npm 官网) 是 Node.js 的软件包管理器。\nnpm init\n\n安装软件安装 jQuery:\nnpm install jquery\nnpm install jquery -g\n\n其中, g 表示全局 global。\n查询某个包的版本查询 npm 服务器上 jquery 的所有版本使用复数形式的 versions:\nnpm view jquery verisions\n\n查询 npm 服务器上 jquery 的最新版本使用单数形式的 version:\nnpm view jquery verision\n\n查询 npm 服务器上 jquery 的详细信息使用 info:\nnpm info jquery\n\n查询 本地 (当前项目) jquery 的信息使用 ls:\nnpm ls jquery\nnpm ls jquery -g\n\n如果尚未安装 jquery, 则返回 empty。\n运行程序使用系统指定目录系统指定目录指: C:/Windows 或 C:/Windows/System32, 只要程序在系统指定目录内, 就可以在命令行 (cmd) 中执行。使用 notepad 打开 test.txt 文件:\nnotepad test.txt\n\n使用绝对路径如果程序不在系统指定目录内, 则可以通过指定绝对路径运行程序。使用 python.exe 打开 test.py 文件\nC:&#x2F;Python&#x2F;python.exe test.py\n\n或者调用相应的程序直接执行:\npython test.py\n\njavac test.java\njava test\n\nnode test.js\n\ngcc test.c -o test.exe\ntest\n\npython (.py) 脚本文件 可直接运行; java (.java) 文件 须使用 javac 编译生成 .class 文件, 再使用 java 执行 .class 文件; javascript (.js) 文件使用 node 直接运行; c (.c) 文件使用 gcc xx.c -o xx.exe 编译生成, 再使用 xx 即可执行文件。\n","slug":"命令行初探","date":"2022-03-24T15:44:35.000Z","categories_index":"","tags_index":"命令行,cd,npm","author_index":"paranoia"}]